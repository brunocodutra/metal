<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Bruno Dutra">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!--<link rel="icon" href="icons/..."> -->
    <title>Metal</title>
    <link href="octicons.css" rel="stylesheet">
    <link href="bootstrap.css" rel="stylesheet">
    <link href="metal.css" rel="stylesheet">
    <style>
      /*!
       * IE10 viewport hack for Surface/desktop Windows 8 bug
       * Copyright 2014-2015 Twitter, Inc.
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
       */
      @-webkit-viewport { width: device-width; }
      @-moz-viewport    { width: device-width; }
      @-ms-viewport     { width: device-width; }
      @-o-viewport      { width: device-width; }
      @viewport         { width: device-width; }
    </style>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.js"></script>
    <script type="text/javascript" src="metal.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-83817633-1', 'auto');
      ga('send', 'pageview');
    </script>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <script>document.body.style.display = "none";</script>
    <div id="content">
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
          <div class="navbar-header">
            <a class="navbar-brand" href="#">
              Metal <small>0.5.1</small>
            </a>
          </div>
          <ul class="nav navbar-nav navbar-left">
            <li id="sections" class="active dropdown">
              <a class="active dropdown-toggle" data-toggle="dropdown" href="#"><span id="name"></span><span class="caret"></span></a>
              <ul id="menu" class="dropdown-menu">
                <li><a href="index.html"><i class="octicon octicon-book"></i><span>Documentation</span></a></li>
                <li><a href="group__metal.html"><i class="octicon octicon-code"></i><span>Reference</span></a></li>
                <li><a href="namespacemembers.html"><i class="octicon octicon-list-unordered"></i><span>Alphabetical Index</span></a></li>
              </ul>
            </li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li>
              <a id="download" aria-label="Download from GitHub" href="https://github.com/brunocodutra/metal/archive/v0.5.1.zip">
                <span class="hidden-xs">Download</span>
                <span class="hidden-xs octicon octicon-cloud-download" aria-hidden="true"></span>
                <span class="visible-xs-block mega-octicon octicon-cloud-download" aria-hidden="true"></span>
              </a>
            </li>
            <li>
              <a aria-label="View on GitHub" href="https://github.com/brunocodutra/metal">
                <span class="hidden-xs">View on GitHub</span>
                <span class="hidden-xs octicon octicon-mark-github" aria-hidden="true"></span>
                <span class="visible-xs-block mega-octicon octicon-mark-github" aria-hidden="true"></span>
              </a>
            </li>
          </ul>
        </div>
      </nav>
      <div class="container">
        <div class="row">
          <div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Metal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#in_a_glimpse">In a Glimpse </a></li>
<li class="level1"><a href="#getting_started">Getting Started </a><ul><li class="level2"><a href="#download">Download </a></li>
<li class="level2"><a href="#install">Install (optional) </a></li>
<li class="level2"><a href="#integration">Integration </a></li>
<li class="level2"><a href="#supported_compilers">Supported Compilers </a></li>
<li class="level2"><a href="#project_organization">Project Organization </a></li>
</ul>
</li>
<li class="level1"><a href="#concepts">Concepts </a><ul><li class="level2"><a href="#value">Value </a></li>
<li class="level2"><a href="#number">Number </a></li>
<li class="level2"><a href="#expression">Expression </a></li>
<li class="level2"><a href="#lambda">Lambda </a></li>
<li class="level2"><a href="#list">List </a></li>
<li class="level2"><a href="#pair">Pair </a></li>
<li class="level2"><a href="#map">Map </a></li>
</ul>
</li>
<li class="level1"><a href="#MPL">Migrating from Boost.MPL </a></li>
<li class="level1"><a href="#examples">Examples </a><ul><li class="level2"><a href="#parsing_raw_literals">Parsing Raw Literals </a></li>
<li class="level2"><a href="#church_booleans">Church Booleans </a></li>
<li class="level2"><a href="#SFINAE">A Word on SFINAE-Friendliness </a></li>
</ul>
</li>
<li class="level1"><a href="#FAQ">Frequently Asked Questions </a><ul><li class="level2"><a href="#FAQ_MPL">What are some advantages of Metal with respect to Boost.MPL? </a></li>
<li class="level2"><a href="#FAQ_Hana">What are some advantages of Metal with respect to Boost.Hana? </a></li>
<li class="level2"><a href="#FAQ_numbers">Why isn&#39;t std::integral_constant always a Number? </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Metal is a header-only C++14 library designed to make metaprogramming easy. It provides a powerful high-level abstraction for compile-time algorithms that mimic the Standard Algorithms Library, hence <b>Metal</b> - <b>Meta</b>programming <b>Al</b>gorithms.</p>
<p>There is a myriad of C++ metaprogramming libraries out there so why Metal?</p>
<ul>
<li><b>Portable</b> - compatible with the <a href="#supported_compilers">most popular compilers</a>.</li>
<li><b>Blazing fast</b> - browse up to date benchmarks at <a href="http://metaben.ch/">metaben.ch</a>.</li>
<li><b>SFINAE-Friendly</b> - <a href="http://en.cppreference.com/w/cpp/language/sfinae">control overload resolution</a> and make the most out of function templates.</li>
<li><b>Metaprogramming made easy</b> - it doesn't have to be hard, <a href="#in_a_glimpse">check it out</a>!</li>
</ul>
<h1><a class="anchor" id="in_a_glimpse"></a>
In a Glimpse </h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;metal.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// First we need some Values</span></div><div class="line"><span class="keyword">union </span>x { <span class="keywordtype">char</span> payload[10]; };</div><div class="line"><span class="keyword">class </span>y { <span class="keyword">public</span>: <span class="keywordtype">char</span> c; };</div><div class="line"><span class="keyword">struct </span>z { <span class="keywordtype">char</span> c; <span class="keywordtype">int</span> i; };</div><div class="line"></div><div class="line"><span class="comment">// ... from which we construct some Lists</span></div><div class="line"><span class="keyword">using</span> l0 = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;&gt;</a>;</div><div class="line"><span class="keyword">using</span> l1 = <a class="code" href="group__list.html#gafd4445b177a59b2363a38e3eff829018">metal::prepend&lt;l0, x&gt;</a>;</div><div class="line"><span class="keyword">using</span> l2 = <a class="code" href="group__list.html#ga648d2eceb42e9089504f531e6f161e8d">metal::append&lt;l1, z&gt;</a>;</div><div class="line"><span class="keyword">using</span> l3 = <a class="code" href="group__list.html#gada3d27d439ffc2ba39a47bd4c83b4f97">metal::insert&lt;l2, metal::number&lt;1&gt;</a>, y&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l1, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l2, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x, z&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l3, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x, y, z&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Lists are versatile, we can check their sizes...</span></div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l0&gt;::value</a> == 0, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l1&gt;::value</a> == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l2&gt;::value</a> == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l3&gt;::value</a> == 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// retrieve their elements...</span></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#gade80d3a9f3af793609378be626a37e44">metal::front&lt;l3&gt;</a>, x&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga120a393928775d8478fcafb858824e1c">metal::back&lt;l3&gt;</a>, z&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga836210f04f726c3b4652b8360b23933b">metal::at</a>&lt;l3, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>&gt;, y&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// count those that satisfy a predicate...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> is_class = <a class="code" href="group__number.html#gaa053345ba4ba5f496aa0d3a5feb15493">metal::as_number&lt;std::is_class&lt;T&gt;</a>&gt;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> is_union = <a class="code" href="group__number.html#gaa053345ba4ba5f496aa0d3a5feb15493">metal::as_number&lt;std::is_union&lt;T&gt;</a>&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__list.html#ga3cc168935e99a9ef8063a6c1422c02da">metal::count_if</a>&lt;l3, <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;is_class&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a> == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga3cc168935e99a9ef8063a6c1422c02da">metal::count_if</a>&lt;l3, <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;is_union&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a> == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// We can create new Lists by removing elements...</span></div><div class="line"><span class="keyword">using</span> l0_ = <a class="code" href="group__list.html#ga95318f943fd0516222dee490515a388a">metal::drop&lt;l3, metal::number&lt;3&gt;</a>&gt;;</div><div class="line"><span class="keyword">using</span> l1_ = <a class="code" href="group__list.html#gabc4aaa8d90a0aee48fe187f405b3bc38">metal::take&lt;l3, metal::number&lt;1&gt;</a>&gt;;</div><div class="line"><span class="keyword">using</span> l2_ = <a class="code" href="group__list.html#gaa65e583f03eb7dde8e39cf5b6aeae124">metal::erase&lt;l3, metal::number&lt;1&gt;</a>&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l0, l0_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l1, l1_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l2, l2_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// by reversing the order of elements...</span></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga2c0aea004081422865731b1f8a903d53">metal::reverse&lt;l0&gt;</a>, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga2c0aea004081422865731b1f8a903d53">metal::reverse&lt;l1&gt;</a>, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga2c0aea004081422865731b1f8a903d53">metal::reverse&lt;l2&gt;</a>, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;z, x&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga2c0aea004081422865731b1f8a903d53">metal::reverse&lt;l3&gt;</a>, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;z, y, x&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// by transforming the elements...</span></div><div class="line"><span class="keyword">using</span> l2ptrs = <a class="code" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform&lt;metal::lambda&lt;std::add_pointer_t&gt;</a>, l2&gt;;</div><div class="line"><span class="keyword">using</span> l3refs = <a class="code" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform&lt;metal::lambda&lt;std::add_lvalue_reference_t&gt;</a>, l3&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l2ptrs, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x*, z*&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l3refs, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;x&amp;, y&amp;, z&amp;&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// even by sorting them...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">using</span> smaller = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;(sizeof(x) &lt; sizeof(y))&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> sorted = <a class="code" href="group__list.html#gaab551bdf7f774225e9779a46eaccac25">metal::sort&lt;l3, metal::lambda&lt;smaller&gt;</a>&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;sorted, <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;y, z, x&gt;</a>&gt;::<a class="code" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// that and much more!</span></div></div><!-- fragment --><p> Check out <a href="#examples">more examples</a> below.</p>
<h1><a class="anchor" id="getting_started"></a>
Getting Started </h1>
<h2><a class="anchor" id="download"></a>
Download </h2>
<p>There are a few ways to get Metal, the easiest might be to simply <a href="http://github.com/brunocodutra/metal/releases">download the latest release</a> as a compressed package.</p>
<p>If you have git installed and would rather have the latest stable Metal, you may consider cloning branch <code>master</code> from GitHub. </p><pre class="fragment">git clone https://github.com/brunocodutra/metal
</pre><p>Likewise, the bleeding edge development version can be obtained by cloning branch <code>develop</code> instead. </p><pre class="fragment">git clone https://github.com/brunocodutra/metal --branch=develop
</pre><h2><a class="anchor" id="install"></a>
Install (optional) </h2>
<p>Metal may optionally be installed system-wide to ease integration with external projects. If you'd rather use Metal locally, you can skip to the <a href="#integration">next section</a>.</p>
<p>Make sure to have CMake v3.4 or newer installed on your system, then, from within an empty directory, issue the following commands. </p><pre class="fragment">cmake /path/to/Metal
cmake --build . --target install
</pre><p>At this point Metal's include tree will be installed in <code>/usr/local/include</code> on Posix systems and <code>C:\Program Files\Metal\include</code> on Windows.</p>
<h2><a class="anchor" id="integration"></a>
Integration </h2>
<p>If you chose to <a href="#install">install Metal system-wide</a>, you just have to make sure the installation prefix is looked up by your compiler.</p>
<p>Using CMake it suffices to add the following to your <code>CMakeLists.txt</code>. </p><pre class="fragment">find_package(Metal REQUIRED)
include_directories(${Metal_INCLUDE_DIR})
</pre><p>To use your local copy of Metal instead, just add its <code>include/</code> sub-directory to the include search paths of your project and you are all set.</p>
<h2><a class="anchor" id="supported_compilers"></a>
Supported Compilers </h2>
<p>The following compilers are tested in continuous integration using <a href="http://travis-ci.org/brunocodutra/metal">Travis CI</a> and <a href="http://ci.appveyor.com/project/brunocodutra/metal">Appveyor CI</a>.</p>
<table class="doxtable">
<tr>
<th>Compiler </th><th>Version  </th></tr>
<tr>
<td>GCC </td><td>&ge; 4.8 </td></tr>
<tr>
<td>Clang </td><td>&ge; 3.4 </td></tr>
<tr>
<td>Xcode </td><td>&ge; 6.4 </td></tr>
<tr>
<td>Visual Studio </td><td>&ge; 14 (2015) </td></tr>
<tr>
<td>MinGW </td><td>&ge; 5 </td></tr>
</table>
<h2><a class="anchor" id="project_organization"></a>
Project Organization </h2>
<p>Header files are divided in modules named after each <a href="#concepts">concept</a>. Modules are organized in directories and contain algorithms that operate on models of that concept. The complete hierarchy of modules and headers is available on <a href="http://github.com/brunocodutra/metal/tree/master/include">Metal's repository</a> on GitHub.</p>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"> Tip</span></div><div class="panel-body"> You may simply include <code>metal.hpp</code> and get access to all that Metal has to offer without concerning yourself with which specific headers to include. </div></div><h1><a class="anchor" id="concepts"></a>
Concepts </h1>
<p>Template metaprogramming may be seen as a language of its own right. It shares the usual syntax of C++ templates, but has unique semantics. Because constructs assume different meanings in its context it is useful to define a few key concepts.</p>
<h2><a class="anchor" id="value"></a>
Value </h2>
<p><a href="#value">Values</a> are the objects of metaprogramming.</p>
<h3>Requirements</h3>
<p>Any type is a <a href="#value">Value</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> val = int;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> val = decltype(3.14);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>val</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">};</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> not_a_val;</div></div><!-- fragment --><div class="fragment"><div class="line">decltype(<span class="keyword">auto</span>) not_a_val = 3.14;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>not_a_val</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">};</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__value.html#gaff19a67d69d7ab4804e61d8c6d0dc76a">metal::value</a>, <a class="el" href="group__value.html#ga4588f7571a3129dc67d4defa403426f8">metal::is_value</a></p>
<h2><a class="anchor" id="number"></a>
Number </h2>
<p>A <a href="#number">Number</a> is a compile-time representation of a numerical value.</p>
<h3>Requirements</h3>
<p><code>num</code> is a model of <a href="#number">Number</a> if and only if <code>num</code> is a specialization of <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a></code>.</p>
<div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"> Note</span></div><div class="panel-body"> <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>&lt;n&gt;</code> is guaranteed to be an alias template to <code>std::integral_constant&lt;<a class="el" href="group__number.html#ga4e051f5efd9de86772e0622414cee2df">metal::int_</a>, n&gt;</code>. </div></div><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> num = <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> num = metal::number&lt;-1&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> num = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;'a'&gt;</a>;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>not_a_num :</div><div class="line">    <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a></div><div class="line">{};</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>, <a class="el" href="group__number.html#ga4e051f5efd9de86772e0622414cee2df">metal::int_</a></p>
<h2><a class="anchor" id="expression"></a>
Expression </h2>
<p><a href="#expression">Expressions</a>, also called <em>metafunctions</em>, are mappings over the set of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p><code>expr</code> is a model of <a href="#expression">Expression</a> if and only if <code>expr</code> is a class, union or alias template that only expects <a href="#value">Values</a> as arguments.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... vals&gt;</div><div class="line"><span class="keyword">using</span> expr = metal::number&lt;<span class="keyword">sizeof</span>...(vals)&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">struct </span>expr;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span>...&gt; <span class="comment">// non-type parameter</span></div><div class="line"><span class="keyword">struct </span>not_an_expr;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> v&gt; <span class="comment">// non-type parameter</span></div><div class="line"><span class="keyword">using</span> not_an_expr = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;v&gt;</a>;</div></div><!-- fragment --> <h2><a class="anchor" id="lambda"></a>
Lambda </h2>
<p><a href="#lambda">Lambdas</a>, short for <em>Lambda Expressions</em>, are <a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class</a> <a href="#expression">Expressions</a>. As <a href="#value">Values</a> themselves, <a href="#lambda">Lambdas</a> can serve both as argument as well as return value to other <a href="#expression">Expressions</a> and <a href="#lambda">Lambdas</a>, thus enabling <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order</a> composition.</p>
<h3>Requirements</h3>
<p><code>lbd</code> is a model of <a href="#lambda">Lambda</a> if and only if <code>lbd</code> is a specialization of <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a></code>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;std::add_pointer_t&gt;</a>;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>, <a class="el" href="group__lambda.html#gafacca9003bb9e12d31b08a678b108e12">metal::is_lambda</a></p>
<h2><a class="anchor" id="list"></a>
List </h2>
<p>A <a href="#list">List</a> is a sequence of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p><code>list</code> is a model of <a href="#list">List</a> if and only if <code>list</code> is a specialization of <code><a class="el" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a></code>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> l = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;&gt;</a>; <span class="comment">// an empty list</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> l = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int, int*, int&amp;&gt;</a>;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>, <a class="el" href="group__list.html#ga0d35b093a78a38d60906901eb78a5946">metal::is_list</a></p>
<h2><a class="anchor" id="pair"></a>
Pair </h2>
<p>A <a href="#pair">Pair</a> is a couple of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#pair">Pair</a> is any <a href="#list">List</a> whose size is 2.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> p = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int, unsigned&gt;</a>;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair</a>, <a class="el" href="group__pair.html#gac3091dc09ba574a6386bd58842e91eb8">metal::is_pair</a>, <a class="el" href="group__pair.html#gaece246e2d9b4dbf76771ad5245863021">metal::first</a>, <a class="el" href="group__pair.html#ga828649360b00a0f39150966ad239608e">metal::second</a></p>
<h2><a class="anchor" id="map"></a>
Map </h2>
<p>A <a href="#map">Map</a> is a collection of unique <a href="#value">Values</a>, each of which associated with another <a href="#value">Value</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#map">Map</a> is a <a href="#list">List</a> of <a href="#pair">Pairs</a>, whose first elements are all distinct, that is </p><pre class="fragment">[[k0, v0], ..., [kn, vn]]; ki != kj for all i, j in {0, n} and i != j
</pre><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> m = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;&gt;</a>; <span class="comment">// an empty map</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> m = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int, long&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;float, double&gt;</a></div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> not_a_map = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt; <span class="comment">// repeated keys</span></div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int, int*&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int, int&amp;&gt;</a></div><div class="line">&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> not_a_map = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt; <span class="comment">// not a list of pairs</span></div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;int&gt;</a>,</div><div class="line">    metal::list&lt;int, int&amp;&gt;</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__map.html#ga28dd5182561a0c200b9785c83cb616fe">metal::map</a>, <a class="el" href="group__map.html#ga74aaca3fae66a7618dff3f439927d9ed">metal::is_map</a>, <a class="el" href="group__map.html#ga3636ee6af332209b8742e6a127f684ff">metal::keys</a>, <a class="el" href="group__map.html#ga1f02a299118058aa6d36c9558cb52771">metal::values</a></p>
<h1><a class="anchor" id="MPL"></a>
Migrating from Boost.MPL </h1>
<p>Metal was heavily influenced by Boost.MPL, from which it inherited the convention of naming algorithms after their counterparts in the C++ standard library. For this reason, metaprograms written using Metal might resemble those written using Boost.MPL, but there are fundamental differences between these libraries that you must keep in mind when porting a legacy metaprogram that uses Boost.MPL to modern C++ using Metal.</p>
<p>Boost.MPL is notable for employing various tricks to emulate features that only became directly supported by the core language much later on with C++11. Most notably, Boost.MPL relies on a template arguments to emulate variadic templates and create an illusion that <em>Sequences</em>, such as <code>mpl::vector</code> or <code>mpl::map</code>, can hold an arbitrary number of elements. However, because these templates could not be truly variadic, every possible size of these <em>Sequences</em> had to be enumerated one by one as a distinct numbered version of the template.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elm_1&gt;</div><div class="line"><span class="keyword">struct </span>sequence_1 {};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elm_1, <span class="keyword">typename</span> elm_2&gt;</div><div class="line"><span class="keyword">struct </span>sequence_2 {};</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elm_1, <span class="keyword">typename</span> elm_2, <span class="comment">/*...*/</span> <span class="keyword">typename</span> elm_n&gt;</div><div class="line"><span class="keyword">struct </span>sequence_n {};</div></div><!-- fragment --><p> This trick clearly doesn't scale well and implies there must be an upper limit to the size of <em>Sequences</em>. Indeed Boost.MPL limits the sizes of sequences to only a couple of dozen elements by default. Moreover, because this boilerplate is too troublesome to maintain, Boost.MPL relies heavily on the C++ preprocessor, which on one hand reduces code redundancy, but on the other hand dramatically impacts compilation time figures.</p>
<p>Metal has none of these issues, since it takes advantage of variadic templates to reduce that boilerplate to a one-liner, while at the same time overcoming all of the drawbacks mentioned.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">struct </span>sequence {};</div></div><!-- fragment --><p> Indeed, Metal <a href="#list">Lists</a> and <a href="#map">Maps</a> can easily exceed the hundreds and even thousands of elements with little impact to the compiler performance. For up to date benchmark figures, visit <a href="http://metaben.ch/">metaben.ch</a>.</p>
<p>Another important difference that arises from the lack of language support at the time Boost.MPL was designed, is the fact that it had no other means of expressing metafunctions other than by the rather verbose idiom of declaring a nested type alias within template classes.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>na {};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_1 = na, <span class="keyword">typename</span> arg_2 = na, <span class="comment">/*...*/</span> <span class="keyword">typename</span> arg_n = na&gt;</div><div class="line"><span class="keyword">struct </span>metafunction</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> result type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_1, <span class="keyword">typename</span> arg_2, <span class="comment">/*...*/</span> <span class="keyword">typename</span> arg_n&gt;</div><div class="line"><span class="keyword">struct </span>compound_metafunction</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> metafunction&lt;</div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_1&gt;::type,</div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_2&gt;::type,</div><div class="line">        <span class="comment">/*...*/</span></div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_n&gt;::type</div><div class="line">    &gt;::type type;</div><div class="line">};</div></div><!-- fragment --><p> Metal on the other hand is able to take advantage of <a href="http://en.cppreference.com/w/cpp/language/type_alias">alias templates</a> and make it much less verbose</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... args&gt;</div><div class="line"><span class="keyword">using</span> metafunction = result;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... args&gt;</div><div class="line"><span class="keyword">using</span> compound_metafunction = metafunction&lt;metafunction&lt;args&gt;...&gt;;</div></div><!-- fragment --><p> ... but that is not all that there's to it. While template aliases produce SFINAE-friendly errors, substitution errors on nested types prevent the <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> rule from kicking in and trigger hard compilation errors instead, which is another important drawback of Boost.MPL when compared to Metal. For a discussion about the importance of SFINAE-friendliness, take a look at <a class="el" href="index.html#SFINAE">A Word on SFINAE-Friendliness </a>.</p>
<p>For the reasons discussed, Metal cannot interoperate with Boost.MPL out of the box, but fortunately it is always possible to map Boost.MPL concepts to their equivalents in Metal, such as <em>Sequences</em> to <a href="#list">Lists</a>, <em>Metafunction Classes</em> to <a href="#lambda">Lambdas</a> and <em>Integral Constants</em> to <a href="#number">Numbers</a>. To ease the migration, Metal provides a built in helper <code><a class="el" href="group__external.html#gaede6847ad3e0bb64c0c921112b29930e">metal::from_mpl</a></code> that does just that for you, simply include <code>metal/external/mpl.hpp</code> to make it available.</p>
<h1><a class="anchor" id="examples"></a>
Examples </h1>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"> Tip</span></div><div class="panel-body"> In the following examples, <code>IS_SAME(X, Y)</code> is just a terser shorthand for <code>static_assert(std::is_same&lt;X, Y&gt;{}, "")</code>. </div></div><h2><a class="anchor" id="parsing_raw_literals"></a>
Parsing Raw Literals </h2>
<hr/>
<p>If you ever considered augmenting <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>, so that instead of the rather clunky <a href="http://en.cppreference.com/w/cpp/utility/tuple/get"><code>std::get&lt;N&gt;()</code></a></p>
<div class="fragment"><div class="line">static_assert(std::get&lt;1&gt;(std::tuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}) == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> one could use the more expressive subscript operator <code>[N]</code></p>
<div class="strike"> <div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --></div><p>you might have come up with something like this</p>
<div class="strike"> <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> operator [](std::size_t i)</div><div class="line">    -&gt; std::tuple_element_t&lt;i, std::tuple&lt;T...&gt;&gt;&amp; {</div><div class="line">    <span class="keywordflow">return</span> std::get&lt;i&gt;(*this);</div><div class="line">}</div></div><!-- fragment --></div><p>only to realize the hard way that this is simply not valid C++14.</p>
<blockquote class="doxtable">
<p>error: non-type template argument is not a constant expression </p>
</blockquote>
<p>While the keyword <a href="http://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code></a> tells the compiler the value returned by <code>operator []</code> <em>might</em> be a compile time constant, it imposes no such constraint on its arguments, which may as well be unknown at compile-time. It might seem we are out of luck at this point, but let us not forget that long before C++ had <code>constexpr</code> variables, integral constants strictly known at compile time could be expressed with the help of non-type template parameters.</p>
<p>So how about refactoring <code>operator []</code> to take an instance of <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a></code> and relying on template pattern matching to extract its non-type template argument?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</div><div class="line"><span class="keyword">struct </span>AugmentedTuple :</div><div class="line">    std::tuple&lt;T...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> std::tuple&lt;T...&gt;::tuple;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;metal::<span class="keywordtype">int</span>_ i&gt;</div><div class="line">    constexpr <span class="keyword">auto</span> operator [](<a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a>)</div><div class="line">        -&gt; <a class="code" href="group__list.html#ga836210f04f726c3b4652b8360b23933b">metal::at</a>&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;T...&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a>&gt;&amp; {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;i&gt;(*this);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[<a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>{}] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> That looks promising, but then again <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>&lt;1&gt;{}</code> is even clunkier than <code>std::get&lt;1&gt;()</code>, we want something more expressive.</p>
<p>A custom <a href="http://en.cppreference.com/w/cpp/language/user_literal">literal operator</a> that constructs <a class="el" href="index.html#number">Numbers</a> out of integer literals could help reducing the verbosity</p>
<div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1_c] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> but how is <code>operator ""_c</code> implemented?</p>
<p>It might be tempting to try something like this</p>
<div class="strike"> <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i)</div><div class="line">    -&gt; <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a> {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --></div><p>but let us not forget the reason why we got this far down the road to begin with, recall we can't instantiate a template using a non-<code>constexpr</code> variable as argument!</p>
<p>At this point, a watchful reader might argue that in theory there is no real reason for this to be rejected, since the literal value must always be known at compile-time and that makes a lot of sense indeed, but unfortunately that's just not how C++14 works.</p>
<p>All is not lost however, because we can still parse raw literals, in other words, we are in for some fun!</p>
<h3>The Raw Literal Operator Template</h3>
<p>Raw literal operator templates in C++ are defined as a nullary constexpr function templated over <code>char...</code></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">char</span>... cs&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_raw()</div><div class="line">    -&gt; <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers</a>&lt;cs...&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --><p> where <code>cs...</code> are mapped to the exact characters that make up the literal, including the prefixes <code>0x</code> and <code>0b</code></p>
<div class="fragment"><div class="line">IS_SAME(decltype(371_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a>);</div><div class="line">IS_SAME(decltype(0x371_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'0', 'x', '3', '7', '1'&gt;</a>);</div></div><!-- fragment --><p> as well as digit separators</p>
<div class="fragment"><div class="line">IS_SAME(decltype(3<span class="charliteral">&#39;7&#39;</span>1_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '\'', '7', '\'', '1'&gt;</a>);</div></div><!-- fragment --> <h3>The <code>operator ""_c</code></h3>
<p>We start by defining the literal operator <code>_c</code> as a function that forwards the raw literal characters as a <a href="#list">List</a> of <a href="#number">Numbers</a> to <code>parse_number</code> and returns a default constructed object of whatever type it aliases to, which in this case is guaranteed to be a <a href="#number">Number</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">char</span>... cs&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c()</div><div class="line">    -&gt; parse_number&lt;<a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers</a>&lt;cs...&gt;&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --> <h3>Resolving the Radix</h3>
<p>In its turn <code>parse_number</code> strips the prefix, if any, thus resolving the radix, then forwards the remaining characters to <code>parse_digits</code>, which is in charge of translating the raw characters to the numerical values they represent. The radix and digits are then forwarded to <code>assemble_number</code>, which adds up the individual digits according to the radix.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;10&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;8&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;x&#39;&gt;, tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;16&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;X&#39;&gt;, tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;16&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;b&#39;&gt;, tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;2&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number_impl&lt;</div><div class="line">    metal::<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;B&#39;&gt;, tokens...&gt;</div><div class="line">&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;</div><div class="line">        <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;2&gt;</a>,</div><div class="line">        parse_digits&lt;<a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;tokens...&gt;&gt;</div><div class="line">    &gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tokens&gt;</div><div class="line"><span class="keyword">using</span> parse_number = <span class="keyword">typename</span> parse_number_impl&lt;tokens&gt;::type;</div></div><!-- fragment --> <h3>Parsing Digits</h3>
<p>Before translating characters to their corresponding numerical values, we need to get rid of all digit separators that may be in the way. To do that we'll use <code><a class="el" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove</a></code>, which takes a <a href="#list">List</a> <code>l</code> and a <a href="#value">Value</a> <code>val</code> and returns another <a href="#list">List</a> that contains every element in <code>l</code> and in the same order, except for those that are the same as <code>val</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> tokens = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '\'', '7', '\'', '1'&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    <a class="code" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove</a>&lt;tokens, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;'\''&gt;</a>&gt;,</div><div class="line">    <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> The remaining characters can then be individually parsed with the help of <code><a class="el" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform</a></code>, which takes a <a href="#lambda">Lambda</a> <code>lbd</code> and a <a href="#list">List</a> <code>l</code> and returns another <a href="#list">List</a> that contains the <a class="el" href="index.html#value">Values</a> produced by the invocation of <code>lbd</code> for each element in <code>l</code>. </p><pre class="fragment">[lbd(l[0]), lbd(l[1]), ..., lbd(l[n-2]), lbd(l[n-1])]
</pre><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> c&gt;</div><div class="line"><span class="keyword">using</span> parse_digit = <a class="code" href="group__number.html#ga2415cf2aee5bcc168a636139ec18a93f">metal::if_</a>&lt;</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'0'&gt;</a>&gt;, metal::number&lt;0&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'1'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'2'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;2&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'3'&gt;</a>&gt;, metal::number&lt;3&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'4'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;4&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'5'&gt;</a>&gt;, metal::number&lt;5&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'6'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;6&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'7'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;7&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'8'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;8&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'9'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;9&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'a'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;10&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'b'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;11&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'c'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;12&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'d'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;13&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'e'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;14&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'f'&gt;</a>&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;15&gt;</a>,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'A'&gt;</a>&gt;, metal::number&lt;10&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'B'&gt;</a>&gt;, metal::number&lt;11&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'C'&gt;</a>&gt;, metal::number&lt;12&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'D'&gt;</a>&gt;, metal::number&lt;13&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'E'&gt;</a>&gt;, metal::number&lt;14&gt;,</div><div class="line">    <a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;c, metal::number&lt;'F'&gt;</a>&gt;, metal::number&lt;15&gt;</div><div class="line">&gt;;</div></div><!-- fragment --> <div class="fragment"><div class="line">IS_SAME(</div><div class="line">    <a class="code" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform</a>&lt;<a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;parse_digit&gt;</a>, <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a>&gt;,</div><div class="line">    <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> Notice how characters are translated to their actual numerical representation.</p>
<p>Thus we have</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tokens&gt;</div><div class="line"><span class="keyword">using</span> parse_digits = <a class="code" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;parse_digit&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove&lt;tokens, metal::number&lt;'\''&gt;</a>&gt;</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Assembling Numbers</h3>
<p>We now turn to <code>assemble_number</code>. It takes a <a href="#list">List</a> of digits and adds them up according to the radix, in other words </p><pre class="fragment">D0*radix^(n-1) + D1*radix^(n-2) + ... + D{n-2}*radix + D{n-1}
</pre><p>or, recursively, </p><pre class="fragment">((...((0*radix + D0)*radix + D1)*...)*radix + D{n-2})*radix + D{n-1}
</pre><p>This is the equivalent of <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">left folding</a>, or, in the Metal parlance, <code><a class="el" href="group__list.html#ga1d92a78c54e4d4f9bfd5451ea86311b8">metal::accumulate</a></code>, after its run-time counterpart in the standard library.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> radix = metal::number&lt;10&gt;;</div><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">using</span> expr = <a class="code" href="group__number.html#ga980bf986731e49ce9f2b1a8cf3431804">metal::add&lt;metal::mul&lt;radix, x&gt;</a>, y&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;expr&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    <a class="code" href="group__list.html#ga1d92a78c54e4d4f9bfd5451ea86311b8">metal::accumulate</a>&lt;lbd, metal::number&lt;0&gt;, digits&gt;,</div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;371&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> Here we introduced a new <a href="#expression">Expression</a> <code>expr</code> from which we created a <a href="#lambda">Lambda</a>, but we could also have chosen to use <em>bind expressions</em> instead.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> radix = metal::number&lt;10&gt;;</div><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;metal::add&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">        <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;metal::mul&gt;</a>,</div><div class="line">        <a class="code" href="group__lambda.html#ga5081c9fd7989680f63de992a15132628">metal::quote&lt;radix&gt;</a>,</div><div class="line">        metal::_1</div><div class="line">    &gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    <a class="code" href="group__list.html#ga1d92a78c54e4d4f9bfd5451ea86311b8">metal::accumulate</a>&lt;lbd, metal::number&lt;0&gt;, digits&gt;,</div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;371&gt;</a></div><div class="line">);</div></div><!-- fragment --> <div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"> Note</span></div><div class="panel-body"> If <em>bind expressions</em> look scary to you, don't panic, we will exercise <a href="#expression">Expression</a> composition in our <a href="#church_booleans">next example</a>. Here it suffices to keep in mind that <em>bind expressions</em> return anonymous <a href="#lambda">Lambdas</a>, just like <a href="http://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a> returns anonymous functions, and that <code><a class="el" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a></code> and <code><a class="el" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a></code> are the equivalents of <a href="http://en.cppreference.com/w/cpp/utility/functional/placeholders"><code>std::placeholders::_1</code> and <code>std::placeholder::_2</code></a>. </div></div><p>Finally</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> radix, <span class="keyword">typename</span> digits&gt;</div><div class="line"><span class="keyword">using</span> assemble_number = <a class="code" href="group__list.html#ga1d92a78c54e4d4f9bfd5451ea86311b8">metal::accumulate</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">        metal::lambda&lt;metal::add&gt;,</div><div class="line">        <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">            metal::lambda&lt;metal::mul&gt;,</div><div class="line">            metal::quote&lt;radix&gt;,</div><div class="line">            metal::_1</div><div class="line">        &gt;,</div><div class="line">        metal::_2</div><div class="line">    &gt;,</div><div class="line">    metal::number&lt;0&gt;,</div><div class="line">    digits</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Fun With <code>operator ""_c</code></h3>
<div class="fragment"><div class="line">IS_SAME(</div><div class="line">    decltype(01234567_c), <span class="comment">//octal</span></div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;342391&gt;</a></div><div class="line">);</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    decltype(123456789_c), <span class="comment">//decimal</span></div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;123456789&gt;</a></div><div class="line">);</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    decltype(0xABCDEF_c), <span class="comment">//hexadecimal</span></div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;11259375&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> It also works for very long binary literals.</p>
<div class="fragment"><div class="line">IS_SAME(</div><div class="line">    decltype(0b111101101011011101011010101100101011110001000111000111000111000_c),</div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;8888888888888888888&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> And ignores digit separators too.</p>
<div class="fragment"><div class="line">IS_SAME(</div><div class="line">    decltype(1<span class="charliteral">&#39;2&#39;</span>3<span class="charliteral">&#39;4&#39;</span>5<span class="charliteral">&#39;6&#39;</span>7<span class="charliteral">&#39;8&#39;</span>9_c),</div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;123456789&gt;</a></div><div class="line">);</div></div><!-- fragment --> <h2><a class="anchor" id="church_booleans"></a>
Church Booleans </h2>
<hr/>
<p><a href="http://en.wikipedia.org/wiki/Church_encoding#Church_Booleans">Church Booleans</a> refer to a mathematical framework used to express logical operation in the context of <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda notation</a>, where they have an important theoretical significance. Of less practical importance in C++, even in the context of template metaprogramming, they will nevertheless help us acquaint with <em>bind expressions</em> in this toy example.</p>
<p>The boolean constants <code>true_</code> and <code>false_</code> are, by definition, <a class="el" href="index.html#lambda">Lambdas</a> that return respectively the first and second argument with which they are invoked.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a> = <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a> = <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a>;</div></div><!-- fragment --><p> Now, using the fact that booleans are themselves <a class="el" href="index.html#lambda">Lambdas</a>, it's not too hard to realize that invoking a boolean with arguments <code>&lt;false_, true&gt;</code> always yields its negation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> b&gt;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga3131b106df71656a0f4b06c9fd182b75">not_</a> = <a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;b, false_, true_&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(not_&lt;true_&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(not_&lt;false_&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div></div><!-- fragment --><p> However, to enable higher-order composition we really need <code>not_</code> to be a <a class="el" href="index.html#lambda">Lambda </a>, not an <a class="el" href="index.html#expression">Expression </a>. Granted one could easily define former in terms of the latter as <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;not_&gt;</code>, but that would defeat the whole purpose of this exercise, the idea is to use <em>bind expressions</em> directly.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga3131b106df71656a0f4b06c9fd182b75">not_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;metal::invoke&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga5081c9fd7989680f63de992a15132628">metal::quote&lt;false_&gt;</a>, <a class="code" href="group__lambda.html#ga5081c9fd7989680f63de992a15132628">metal::quote&lt;true_&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;not_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;not_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div></div><!-- fragment --><p> Admittedly a little more verbose, but that saves us from introducing a new named alias template.</p>
<p>Using a similar technique, we can also define operators <code>and_</code> and <code>or_</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// x y x y x</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga73d6aa92adfac6cfacb2e935f5b37fb9">and_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a>, metal::_1</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;and_, true_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;and_, true_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;and_, false_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;and_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// x y x x y</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga1411f87040458a68c28936123887ac09">or_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, metal::_2</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;or_, true_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;or_, true_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;or_, false_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;or_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><p> This exercise might me mind-boggling at first, but you'll get used to it soon enough.</p>
<p>Without further ado we present the logical operator <code>xor</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// x y x (not y) y</span></div><div class="line"><span class="keyword">using</span> xor_ = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind&lt;not_, metal::_2&gt;</a>, metal::_2</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;xor_, true_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;xor_, true_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;xor_, false_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#ga883d9c234de3bb9c967eafdbe8286822">metal::invoke&lt;xor_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><p> Notice how we <em>bind</em> <code>not_</code>, which is only possible due to the fact it is a <a class="el" href="index.html#lambda">Lambda </a>.</p>
<h2><a class="anchor" id="SFINAE"></a>
A Word on SFINAE-Friendliness </h2>
<hr/>
<p>An <a href="#expression">Expression</a> is said to be SFINAE-friendly when it is carefully designed so as never to prevent the <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> rule to be triggered. In general, such <a href="#expression">Expressions</a> may only trigger template substitution errors at the point of instantiation of the <em>signature</em> of a type, which includes the instantiation of <a href="http://en.cppreference.com/w/cpp/language/type_alias">alias templates</a> and default template arguments. SFINAE-friendly <a href="#expression">Expressions</a> are exceedingly powerful, because they may be used to drive overload resolution, much like <a href="http://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> does. For this reason, <b>all <a href="#expression">Expressions</a> in Metal are guaranteed to be SFINAE-friendly</b>.</p>
<p>Conversely, a SFINAE-unfriendly <a href="#expression">Expression</a> produces so called <em>hard errors</em>, which require the compilation to halt immediately. Examples of <em>hard errors</em> are failed <code>static_assert</code>'ions or template substitution errors at the point of instantiation of the nested members of a type. SFINAE-unfriendly <a href="#expression">Expressions</a> are very inconvenient, because they force compilation to halt when they are not selected by overload resolution, thereby hindering the usage of the entire overloaded set.</p>
<p>To illustrate how useful SFINAE-friendliness can be, suppose we need a factory function <code>make_array</code> that takes an arbitrary number of arguments and returns a <code>std::array</code>. Because arrays are homogeneous collections, we need the <em>common type</em> of all its arguments, that is, the type to which every argument can be converted to. Fortunately <code>std::common_type_t</code> does just that and is also guaranteed to be SFINAE-friendly as per the C++ Standard.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;std::common_type_t&lt;Xs...&gt;, <span class="keyword">sizeof</span>...(Xs)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Xs&amp;&amp;... xs) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Xs&gt;(xs)...}};</div><div class="line">}</div></div><!-- fragment --><p> There is one caveat to <code>std::common_type_t</code> however: it doesn't work with <code>std::tuple</code>s in general, even though the <em>common tuple</em> is really just a <em>tuple</em> of <em>common types</em>. Hence, we need a new trait that computes the <em>common tuple</em> from a set of <em>tuples</em> so that we may overload <code>make_array</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="keyword">using</span> common_tuple_t = <a class="code" href="group__lambda.html#ga2c9e65a1497c421ba4e180fd7300224e">metal::apply</a>&lt;</div><div class="line">    std::common_type_t&lt;metal::lambda&lt;std::tuple&gt;, <a class="code" href="group__lambda.html#ga5cd9df7f92f4e646724ee8bbcea685c7">metal::as_lambda&lt;Ts&gt;</a>...&gt;,</div><div class="line">    <a class="code" href="group__list.html#gaa4b377d642f35bb6c4bb991d81506e40">metal::transform&lt;metal::lambda&lt;std::common_type_t&gt;</a>, <a class="code" href="group__list.html#ga0254a66706fd0e05a31f9c0c4029775c">metal::as_list&lt;Ts&gt;</a>...&gt;</div><div class="line">&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;</div><div class="line">        common_tuple_t&lt;std::decay_t&lt;Head&gt;, std::decay_t&lt;Tail&gt;...&gt;,</div><div class="line">        1 + <span class="keyword">sizeof</span>...(Tail)</div><div class="line">    &gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Head&amp;&amp; head, Tail&amp;&amp;... tail) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Head&gt;(head), std::forward&lt;Tail&gt;(tail)...}};</div><div class="line">}</div></div><!-- fragment --><p> And it works as expected, for both numerical values</p>
<div class="fragment"><div class="line">IS_SAME(decltype(make_array(42, 42L, 42LL)), std::array&lt;long long, 3&gt;);</div></div><!-- fragment --><p> as well as <code>std::tuple</code>s</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono;</div><div class="line"><span class="keyword">using namespace </span>std::literals::chrono_literals;</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    decltype(</div><div class="line">        make_array(</div><div class="line">            std::make_tuple(42ns, 0x42, 42.f),</div><div class="line">            std::make_tuple(42us, 042L, 42.L),</div><div class="line">            std::make_tuple(42ms, 42LL, 42.0)</div><div class="line">        )</div><div class="line">    ),</div><div class="line">    std::array&lt;std::tuple&lt;nanoseconds, long long, long double&gt;, 3&gt;</div><div class="line">);</div></div><!-- fragment --><p> Now, it might not be obvious to the untrained eye, but the reason why overloading works as expected in this example, is precisely the fact <code>common_tuple_t</code> is SFINAE-friendly. If it weren't, as soon as one attempted to call <code>make_array</code> for anything that isn't a <code>std::tuple</code>, the compilation would halt immediately, even if the first overload would be a perfect match otherwise.</p>
<p>To demonstrate this issue, we'll implement the same common tuple trait, but this time using Boost.Hana, which, contrary to Metal, doesn't provide any guarantees regarding SFINAE-friendliness.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="keyword">using</span> naive_common_tuple_t = <span class="keyword">typename</span> decltype(</div><div class="line">    boost::hana::unpack(</div><div class="line">        boost::hana::zip_with(</div><div class="line">            boost::hana::template_&lt;std::common_type_t&gt;,</div><div class="line">            boost::hana::zip_with(boost::hana::decltype_, std::declval&lt;Ts&gt;())...</div><div class="line">        ),</div><div class="line">        boost::hana::template_&lt;std::tuple&gt;</div><div class="line">    )</div><div class="line">)::type;</div></div><!-- fragment --><p> Now, if we use <code>naive_common_tuple_t</code> to overload <code>make_array</code></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;std::common_type_t&lt;Xs...&gt;, <span class="keyword">sizeof</span>...(Xs)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Xs&amp;&amp;... xs) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Xs&gt;(xs)...}};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;</div><div class="line">        naive_common_tuple_t&lt;std::decay_t&lt;Head&gt;, std::decay_t&lt;Tail&gt;...&gt;,</div><div class="line">        1 + <span class="keyword">sizeof</span>...(Tail)</div><div class="line">    &gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Head&amp;&amp; head, Tail&amp;&amp;... tail) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Head&gt;(head), std::forward&lt;Tail&gt;(tail)...}};</div><div class="line">}</div></div><!-- fragment --><p> it does work as expected for <code>std::tuples</code></p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono;</div><div class="line"><span class="keyword">using namespace </span>std::literals::chrono_literals;</div><div class="line"></div><div class="line">IS_SAME(</div><div class="line">    decltype(</div><div class="line">        make_array(</div><div class="line">            std::make_tuple(42ns, 0x42, 42.f),</div><div class="line">            std::make_tuple(42us, 042L, 42.L),</div><div class="line">            std::make_tuple(42ms, 42LL, 42.0)</div><div class="line">        )</div><div class="line">    ),</div><div class="line">    std::array&lt;std::tuple&lt;nanoseconds, long long, long double&gt;, 3&gt;</div><div class="line">);</div></div><!-- fragment --><p> however it produces a compilation error as soon as we try to make an array of anything that is not a Boost.Hana <em>Sequence</em>, even if the first overload remains available and would be a perfect match as we just verified</p>
<div class="strike"> <div class="fragment"><div class="line">IS_SAME(decltype(make_array(42, 42L, 42LL)), std::array&lt;long long, 3&gt;);</div></div><!-- fragment --></div><blockquote class="doxtable">
<p>error: static_assert failed "hana::zip_with(f, xs, ys...)
requires 'xs' and 'ys...' to be Sequences" </p>
</blockquote>
<h1><a class="anchor" id="FAQ"></a>
Frequently Asked Questions </h1>
<h2><a class="anchor" id="FAQ_MPL"></a>
What are some advantages of Metal with respect to Boost.MPL? </h2>
<hr/>
<p>The most apparent advantage of Metal with respect to Boost.MPL is the fact Metal <a href="#list">Lists</a> and <a href="#map">Maps</a> can easily exceed the hundreds and even thousands of elements with little impact to the compiler performance, whereas Boost.MPL <em>Sequences</em>, such as <code>mpl::vector</code> and <code>mpl::map</code>, are hard-limited to at most a couple dozen elements and even then at much longer compilation times and increased memory consumption. Another obvious improvement is the much terser syntax of Metal made possible by alias templates, which were not available at the time Boost.MPL was developed. Finally, Metal is guaranteed to be SFINAE-friendly, whereas no guarantees whatsoever are made with this respect by Boost.MPL.</p>
<p>Visit <a href="http://metaben.ch/">metaben.ch</a> for up to date benchmarks that compare Metal against Boost.MPL and other notable metaprogramming libraries. For a more detailed discussion on the limitations of Boost.MPL refer to <a class="el" href="index.html#MPL">Migrating from Boost.MPL </a> and for a real world example of the importance of SFINAE-friendliness, check out <a class="el" href="index.html#SFINAE">A Word on SFINAE-Friendliness </a>.</p>
<h2><a class="anchor" id="FAQ_Hana"></a>
What are some advantages of Metal with respect to Boost.Hana? </h2>
<hr/>
<p>As a tool specifically designed for type level programming, Metal is able to provide stronger guarantees and much faster compilation times than Boost.Hana when used for similar purposes. In fact, Metal guarantees SFINAE-friendliness, whereas Boost.Hana does not. Check out <a class="el" href="index.html#SFINAE">A Word on SFINAE-Friendliness </a> for a real world example of the limitations of Boost.Hana with this respect.</p>
<p>Moreover, since Metal <a class="el" href="index.html#concepts">Concepts </a> are defined by their type signatures, it is always safe to use template pattern matching on them to partially specialize class templates or overload function templates, while the types of most Boost.Hana objects is left unspecified and thus cannot be used for these purposes.</p>
<h2><a class="anchor" id="FAQ_numbers"></a>
Why isn't std::integral_constant always a Number? </h2>
<hr/>
<p><a href="#number">Numbers</a> are defined as a specific specialization of <code>std::integral_constant</code>s, whose binary representation is fixed to <code><a class="el" href="group__number.html#ga4e051f5efd9de86772e0622414cee2df">metal::int_</a></code>, an implementation-defined integral type. This design choice stems from the fact two <a href="#value">Values</a> compare equal if and only if they have the same type signature. As <a href="#value">Values</a> themselves, <a href="#number">Numbers</a> are also subject to this requirement, thus had <a href="#number">Numbers</a> been defined as a numerical value <em>plus</em> its binary representation, would two <a href="#number">Numbers</a> only compare equal if they had both the same numerical value <em>and</em> the same binary representation. This is unreasonable in the context of metaprogramming, where the binary representation of numerical values is entirely irrelevant. </p>
</div></div><!-- contents -->
        </div>
      </div>
    </div>
    <div id="footer">
      <div class="container">
        <div class="row text-muted">
          <div class="col-md-12">
            <ul class="list-inline">
              <li><iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=watch&amp;count=true" title="Star on GitHub"></iframe></li>
              <li><iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=fork&amp;count=true" title="Fork on GitHub"></iframe></li>
            </ul>
            &copy; Copyright 2015-2017
            <a href="https://github.com/brunocodutra">Bruno Dutra</a>,
            <span class="hidden-xs">Distributed under the</span>
            <a href="http://www.boost.org/LICENSE_1_0.txt">
              Boost Software License, Version 1.0
            </a>
          </div>
        </div>
      </div>
    </div>
    <script>
      /*!
       * IE10 viewport hack for Surface/desktop Windows 8 bug
       * Copyright 2014-2015 Twitter, Inc.
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
       */
      (function () {
        'use strict';
        if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
          var msViewportStyle = document.createElement('style')
          msViewportStyle.appendChild(
            document.createTextNode(
              '@-ms-viewport{width:auto!important}'
            )
          )
          document.querySelector('head').appendChild(msViewportStyle)
        }
      })();
    </script>
  </body>
</html>
