<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Bruno Dutra">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!--<link rel="icon" href="icons/..."> -->
    <title>Metal</title>
    <link href="octicons.css" rel="stylesheet">
    <link href="bootstrap.css" rel="stylesheet">
    <link href="metal.css" rel="stylesheet">
    <style>
      /*!
       * IE10 viewport hack for Surface/desktop Windows 8 bug
       * Copyright 2014-2015 Twitter, Inc.
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
       */
      @-webkit-viewport { width: device-width; }
      @-moz-viewport    { width: device-width; }
      @-ms-viewport     { width: device-width; }
      @-o-viewport      { width: device-width; }
      @viewport         { width: device-width; }
    </style>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.js"></script>
    <script type="text/javascript" src="metal.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-83817633-1', 'auto');
      ga('send', 'pageview');
    </script>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <script>document.body.style.display = "none";</script>
    <div id="content">
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
          <div class="navbar-header">
            <a class="navbar-brand" href="#">
              Metal <small>1.0.0</small>
            </a>
          </div>
          <ul class="nav navbar-nav navbar-left">
            <li id="sections" class="active dropdown">
              <a class="active dropdown-toggle" data-toggle="dropdown" href="#"><span id="name"></span><span class="caret"></span></a>
              <ul id="menu" class="dropdown-menu">
                <li><a href="index.html"><i class="octicon octicon-book"></i><span>Documentation</span></a></li>
                <li><a href="group__metal.html"><i class="octicon octicon-code"></i><span>Reference</span></a></li>
                <li><a href="namespacemembers.html"><i class="octicon octicon-list-unordered"></i><span>Alphabetical Index</span></a></li>
              </ul>
            </li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li>
              <a id="download" aria-label="Download from GitHub" href="https://github.com/brunocodutra/metal/releases/download/v1.0.0/metal.hpp">
                <span class="hidden-xs">Download</span>
                <span class="hidden-xs octicon octicon-cloud-download" aria-hidden="true"></span>
                <span class="visible-xs-block mega-octicon octicon-cloud-download" aria-hidden="true"></span>
              </a>
            </li>
            <li>
              <a aria-label="View on GitHub" href="https://github.com/brunocodutra/metal">
                <span class="hidden-xs">View on GitHub</span>
                <span class="hidden-xs octicon octicon-mark-github" aria-hidden="true"></span>
                <span class="visible-xs-block mega-octicon octicon-mark-github" aria-hidden="true"></span>
              </a>
            </li>
          </ul>
        </div>
      </nav>
      <div class="container">
        <div class="row">
          <div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Metal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview </a></li>
<li class="level1"><a href="#definitions">Definitions </a><ul><li class="level2"><a href="#value">Value </a></li>
<li class="level2"><a href="#number">Number </a></li>
<li class="level2"><a href="#expression">Expression </a></li>
<li class="level2"><a href="#lambda">Lambda </a></li>
<li class="level2"><a href="#list">List </a></li>
<li class="level2"><a href="#pair">Pair </a></li>
<li class="level2"><a href="#map">Map </a></li>
</ul>
</li>
<li class="level1"><a href="#examples">Examples </a><ul><li class="level2"><a href="#parsing_raw_literals">Parsing Raw Literals </a></li>
<li class="level2"><a href="#church_booleans">Church Booleans </a></li>
<li class="level2"><a href="#automatic_test_cases_generation">Automatic Test Cases Generation </a></li>
<li class="level2"><a href="#SFINAE">A Word on SFINAE-Friendliness </a></li>
</ul>
</li>
<li class="level1"><a href="#quick_start">Quick Start </a></li>
<li class="level1"><a href="#MPL">Migrating from Boost.MPL </a></li>
<li class="level1"><a href="#FAQ">Frequently Asked Questions </a><ul><li class="level2"><a href="#FAQ_MPL">What are some advantages of Metal with respect to Boost.MPL? </a></li>
<li class="level2"><a href="#FAQ_Hana">What are some advantages of Metal with respect to Boost.Hana? </a></li>
<li class="level2"><a href="#FAQ_numbers">Why isn&#39;t std::integral_constant a Number in general? </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Metal is a single header C++11 library designed to make you love template metaprogramming.</p>
<p>There is a myriad of C++ metaprogramming libraries out there so why Metal?</p>
<ul>
<li><b>Portable</b> - compatible with the <a href="http://github.com/brunocodutra/metal#portable">most popular compilers</a>.</li>
<li><b>Blazing fast</b> - browse up to date benchmarks at <a href="http://metaben.ch/">metaben.ch</a>.</li>
<li><b>Trivial Integration</b> - everything you need in a single self-contained header file <a href="http://github.com/brunocodutra/metal/blob/standalone/metal.hpp"><code>metal.hpp</code></a>.</li>
<li><b>SFINAE-Friendly</b> - <a href="#SFINAE">control overload resolution</a> and make the most out of function templates.</li>
</ul>
<h1><a class="anchor" id="overview"></a>
Overview </h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;metal.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// First we need some Values</span></div><div class="line"><span class="keyword">union </span>x { <span class="keywordtype">char</span> payload[10]; };</div><div class="line"><span class="keyword">class </span>y { <span class="keyword">public</span>: <span class="keywordtype">char</span> c; };</div><div class="line"><span class="keyword">struct </span>z { <span class="keywordtype">char</span> c; <span class="keywordtype">int</span> i; };</div><div class="line"></div><div class="line"><span class="comment">// ... from which we construct some Lists</span></div><div class="line"><span class="keyword">using</span> l0 = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;&gt;</a>;</div><div class="line"><span class="keyword">using</span> l1 = <a class="code" href="group__list.html#gafd4445b177a59b2363a38e3eff829018">metal::prepend&lt;l0, x&gt;</a>;</div><div class="line"><span class="keyword">using</span> l2 = <a class="code" href="group__list.html#ga648d2eceb42e9089504f531e6f161e8d">metal::append&lt;l1, z&gt;</a>;</div><div class="line"><span class="keyword">using</span> l3 = <a class="code" href="group__list.html#gada3d27d439ffc2ba39a47bd4c83b4f97">metal::insert&lt;l2, metal::number&lt;1&gt;</a>, y&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l1, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l2, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x, z&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l3, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x, y, z&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Lists are versatile, we can check their sizes...</span></div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l0&gt;::value</a> == 0, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l1&gt;::value</a> == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l2&gt;::value</a> == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga85e9d81c96ec58af9ac5fddeed68d516">metal::size&lt;l3&gt;::value</a> == 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// retrieve their elements...</span></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#gade80d3a9f3af793609378be626a37e44">metal::front&lt;l3&gt;</a>, x&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga120a393928775d8478fcafb858824e1c">metal::back&lt;l3&gt;</a>, z&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga464360c13ed9ace9b434aa535da8ac0f">metal::at</a>&lt;l3, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>&gt;, y&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// count those that satisfy a predicate...</span></div><div class="line">static_assert(<a class="code" href="group__list.html#ga3cc168935e99a9ef8063a6c1422c02da">metal::count_if</a>&lt;l3, <a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_class&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a> == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga3cc168935e99a9ef8063a6c1422c02da">metal::count_if</a>&lt;l3, <a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_union&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a> == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// We can create new Lists by removing elements...</span></div><div class="line"><span class="keyword">using</span> l0_ = <a class="code" href="group__list.html#ga95318f943fd0516222dee490515a388a">metal::drop&lt;l3, metal::number&lt;3&gt;</a>&gt;;</div><div class="line"><span class="keyword">using</span> l1_ = <a class="code" href="group__list.html#gabc4aaa8d90a0aee48fe187f405b3bc38">metal::take&lt;l3, metal::number&lt;1&gt;</a>&gt;;</div><div class="line"><span class="keyword">using</span> l2_ = <a class="code" href="group__list.html#ga0b4fbd5e9fb3fc1140bc03805a24f150">metal::erase&lt;l3, metal::number&lt;1&gt;</a>&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l0, l0_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l1, l1_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same&lt;l2, l2_&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// by reversing the order of elements...</span></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga05f32e37bf27cc5da074db9434b66b08">metal::reverse&lt;l0&gt;</a>, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga05f32e37bf27cc5da074db9434b66b08">metal::reverse&lt;l1&gt;</a>, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga05f32e37bf27cc5da074db9434b66b08">metal::reverse&lt;l2&gt;</a>, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;z, x&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;<a class="code" href="group__list.html#ga05f32e37bf27cc5da074db9434b66b08">metal::reverse&lt;l3&gt;</a>, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;z, y, x&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// by transforming the elements...</span></div><div class="line"><span class="keyword">using</span> l2ptrs = <a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform&lt;metal::lazy&lt;std::add_pointer&gt;</a>, l2&gt;;</div><div class="line"><span class="keyword">using</span> l3refs = <a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform&lt;metal::lazy&lt;std::add_lvalue_reference&gt;</a>, l3&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l2ptrs, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x*, z*&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;l3refs, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;x&amp;, y&amp;, z&amp;&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// even by sorting them...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">using</span> smaller = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;(sizeof(x) &lt; sizeof(y))&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> sorted = <a class="code" href="group__list.html#ga145a2fb345da4a0a994bc958efc61560">metal::sort&lt;l3, metal::lambda&lt;smaller&gt;</a>&gt;;</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__value.html#gaa31c68bc893b6d1beaec615c7ab3c3d0">metal::same</a>&lt;sorted, <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;y, z, x&gt;</a>&gt;::<a class="code" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// that and much more!</span></div></div><!-- fragment --> <h1><a class="anchor" id="definitions"></a>
Definitions </h1>
<p>Template metaprogramming may be seen as a language of its own right, it shares the usual syntax of C++ templates, but has its own unique semantics. Because constructs assume different meanings in its context it is useful to define a few key concepts.</p>
<h2><a class="anchor" id="value"></a>
Value </h2>
<p><a href="#value">Values</a> are the objects of metaprogramming.</p>
<h3>Requirements</h3>
<p>Any type is a <a href="#value">Value</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> val = int;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> val = decltype(3.14);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>val { <span class="comment">/*...*/</span> };</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> not_a_val;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> not_a_val = 3.14;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>not_a_val { <span class="comment">/*...*/</span> };</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__value.html#ga07db04c3ea0fe7965e933fa0119c9b93">metal::value</a>, <a class="el" href="group__value.html#ga4588f7571a3129dc67d4defa403426f8">metal::is_value</a></p>
<h2><a class="anchor" id="number"></a>
Number </h2>
<p>A <a href="#number">Number</a> is a compile-time representation of a numerical value.</p>
<h3>Requirements</h3>
<p><code>num</code> is a model of <a href="#number">Number</a> if and only if <code>num</code> is a specialization of <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a></code>.</p>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"> Tip</span></div><div class="panel-body"> <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>&lt;n&gt;</code> is guaranteed to be an alias template to <code>std::integral_constant&lt;<a class="el" href="group__number.html#ga4e051f5efd9de86772e0622414cee2df">metal::int_</a>, n&gt;</code>. </div></div><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> num = <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> num = metal::number&lt;-1&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> num = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;'a'&gt;</a>;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>not_a_num :</div><div class="line">    <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a></div><div class="line">{};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> not_a_num = std::integral_constant&lt;int, 0&gt;;</div></div><!-- fragment --> <h3>FAQ</h3>
<p><a class="el" href="index.html#FAQ_numbers">Why isn't std::integral_constant a Number in general? </a></p>
<h3>See Also</h3>
<p><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>, <a class="el" href="group__number.html#ga1a7355bbc4395a349a12646ac66b8876">metal::is_number</a>, <a class="el" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a></p>
<h2><a class="anchor" id="expression"></a>
Expression </h2>
<p><a href="#expression">Expressions</a>, also called <em>metafunctions</em>, are mappings over the set of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p><code>expr</code> is a model of <a href="#expression">Expression</a> if and only if <code>expr</code> is a class, union or alias template that only expects <a href="#value">Values</a> as arguments.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... vals&gt;</div><div class="line"><span class="keyword">using</span> expr = metal::number&lt;<span class="keyword">sizeof</span>...(vals)&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">struct </span>expr;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span>...&gt; <span class="comment">// non-type parameter</span></div><div class="line"><span class="keyword">struct </span>not_an_expr;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> v&gt; <span class="comment">// non-type parameter</span></div><div class="line"><span class="keyword">using</span> not_an_expr = <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;v&gt;</a>;</div></div><!-- fragment --> <h2><a class="anchor" id="lambda"></a>
Lambda </h2>
<p><a href="#lambda">Lambdas</a>, short for <em>Lambda Expressions</em>, are <a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class</a> <a href="#expression">Expressions</a>. As <a href="#value">Values</a> themselves, <a href="#lambda">Lambdas</a> can serve both as argument as well as return value to other <a href="#expression">Expressions</a> and <a href="#lambda">Lambdas</a>, thus enabling <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order</a> composition.</p>
<h3>Requirements</h3>
<p><code>lbd</code> is a model of <a href="#lambda">Lambda</a> if and only if <code>lbd</code> is a specialization of <code><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a></code>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> expr = T*;</div><div class="line"></div><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;expr&gt;</a>;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a>, <a class="el" href="group__lambda.html#gafacca9003bb9e12d31b08a678b108e12">metal::is_lambda</a>, <a class="el" href="group__lambda.html#ga5cd9df7f92f4e646724ee8bbcea685c7">metal::as_lambda</a></p>
<h2><a class="anchor" id="list"></a>
List </h2>
<p>A <a href="#list">List</a> is a sequence of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p><code>list</code> is a model of <a href="#list">List</a> if and only if <code>list</code> is a specialization of <code><a class="el" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a></code>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a> = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;&gt;</a>; <span class="comment">// an empty list</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a> = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int, int*, int&amp;&gt;</a>;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> not_a_list = std::tuple&lt;int, int*, int&amp;&gt;; <span class="comment">// not a specialization of metal::list</span></div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>, <a class="el" href="group__list.html#ga0d35b093a78a38d60906901eb78a5946">metal::is_list</a>, <a class="el" href="group__list.html#ga0254a66706fd0e05a31f9c0c4029775c">metal::as_list</a></p>
<h2><a class="anchor" id="pair"></a>
Pair </h2>
<p>A <a href="#pair">Pair</a> is a couple of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#pair">Pair</a> is any <a href="#list">List</a> whose size is 2.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">pair</a> = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int, unsigned&gt;</a>;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> not_a_pair = std::pair&lt;int, unsigned&gt;; <span class="comment">// not a List</span></div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair</a>, <a class="el" href="group__pair.html#gac3091dc09ba574a6386bd58842e91eb8">metal::is_pair</a>, <a class="el" href="group__pair.html#ga18e68060d1251f1ba5ceb608ffee7ef2">metal::as_pair</a></p>
<h2><a class="anchor" id="map"></a>
Map </h2>
<p>A <a href="#map">Map</a> is a collection of unique <a href="#value">Values</a>, each of which associated with another <a href="#value">Value</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#map">Map</a> is a <a href="#list">List</a> of <a href="#pair">Pairs</a>, whose first elements are all distinct, that is </p><pre class="fragment">[[k0, v0], ..., [kn, vn]]; ki != kj for all i, j in {0, n} and i != j
</pre><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> m = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;&gt;</a>; <span class="comment">// an empty map</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> m = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int, long&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;float, double&gt;</a></div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> not_a_map = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt; <span class="comment">// repeated keys</span></div><div class="line">    <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int, int*&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int, int&amp;&gt;</a></div><div class="line">&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> not_a_map = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt; <span class="comment">// not a list of pairs</span></div><div class="line">    <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list&lt;int&gt;</a>,</div><div class="line">    metal::list&lt;int, int&amp;&gt;</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__map.html#ga3638b99b7517ef8f7536d1190bb57d51">metal::map</a>, <a class="el" href="group__map.html#ga74aaca3fae66a7618dff3f439927d9ed">metal::is_map</a>, <a class="el" href="group__map.html#gaca72aa14dafc923fd96aa220a8f049d5">metal::as_map</a></p>
<h1><a class="anchor" id="examples"></a>
Examples </h1>
<div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"> Note</span></div><div class="panel-body"> In the following examples, <code>IS_SAME(X, Y)</code> is just a terser shorthand for <code>static_assert(std::is_same&lt;X, Y&gt;{}, "")</code>. </div></div><h2><a class="anchor" id="parsing_raw_literals"></a>
Parsing Raw Literals </h2>
<hr/>
<p>If you ever considered augmenting <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>, so that instead of the rather clunky <a href="http://en.cppreference.com/w/cpp/utility/tuple/get"><code>std::get&lt;N&gt;()</code></a></p>
<div class="fragment"><div class="line">static_assert(std::get&lt;1&gt;(std::tuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}) == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> one could use the more expressive subscript operator <code>[N]</code></p>
<div class="strike"> <div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --></div><p>you might have come up with something like this</p>
<div class="strike"> <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> operator [](std::size_t i)</div><div class="line">    -&gt; std::tuple_element_t&lt;i, std::tuple&lt;T...&gt;&gt;&amp; {</div><div class="line">    <span class="keywordflow">return</span> std::get&lt;i&gt;(*this);</div><div class="line">}</div></div><!-- fragment --></div><p>only to realize the hard way that this is simply not valid C++.</p>
<blockquote class="doxtable">
<p>error: non-type template argument is not a constant expression </p>
</blockquote>
<p>While the keyword <a href="http://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code></a> tells the compiler the value returned by <code>operator []</code> <em>might</em> be a compile time constant, it imposes no such constraint on its arguments, which may as well be unknown at compile-time. It might seem we are out of luck at this point, but let us not forget that long before C++ had <code>constexpr</code> variables, integral constants strictly known at compile time could be expressed with the help of non-type template parameters.</p>
<p>So how about refactoring <code>operator []</code> to take an instance of <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a></code> and relying on template pattern matching to extract its non-type template argument?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</div><div class="line"><span class="keyword">struct </span>AugmentedTuple :</div><div class="line">    std::tuple&lt;T...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> std::tuple&lt;T...&gt;::tuple;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;metal::<span class="keywordtype">int</span>_ i&gt;</div><div class="line">    constexpr <span class="keyword">auto</span> operator [](<a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a>)</div><div class="line">        -&gt; <a class="code" href="group__list.html#ga464360c13ed9ace9b434aa535da8ac0f">metal::at</a>&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;T...&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a>&gt;&amp; {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;i&gt;(*this);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[<a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>{}] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> That looks promising, but then again <code><a class="el" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number</a>&lt;1&gt;{}</code> is even clunkier than <code>std::get&lt;1&gt;()</code>, we want something more expressive.</p>
<p>A custom <a href="http://en.cppreference.com/w/cpp/language/user_literal">literal operator</a> that constructs <a class="el" href="index.html#number">Numbers</a> out of integer literals could help reducing the verbosity</p>
<div class="fragment"><div class="line">static_assert(AugmentedTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1_c] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> but how is <code>operator ""_c</code> implemented?</p>
<p>It might be tempting to try something like this</p>
<div class="strike"> <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i)</div><div class="line">    -&gt; <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;i&gt;</a> {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --></div><p>but let us not forget the reason why we got this far down the road to begin with, recall we can't instantiate a template using a non-<code>constexpr</code> variable as argument!</p>
<p>All is not lost however, because we can still parse raw literals, in other words, we are in for some fun!</p>
<h3>The Raw Literal Operator Template</h3>
<p>Raw literal operator templates in C++ are defined as a nullary constexpr function templated over <code>char...</code></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">char</span>... cs&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_raw()</div><div class="line">    -&gt; <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers</a>&lt;cs...&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --><p> where <code>cs...</code> are mapped to the exact characters that make up the literal, including the prefixes <code>0x</code> and <code>0b</code></p>
<div class="fragment"><div class="line">IS_SAME(decltype(371_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a>);</div><div class="line">IS_SAME(decltype(0x371_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'0', 'x', '3', '7', '1'&gt;</a>);</div></div><!-- fragment --><p> as well as digit separators</p>
<div class="fragment"><div class="line">IS_SAME(decltype(3<span class="charliteral">&#39;7&#39;</span>1_raw), <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '\'', '7', '\'', '1'&gt;</a>);</div></div><!-- fragment --> <h3>The <code>operator ""_c</code></h3>
<p>We start by defining the literal operator <code>_c</code> as a function that forwards the raw literal characters as a <a href="#list">List</a> of <a href="#number">Numbers</a> to <code>parse_number</code> and returns a default constructed object of whatever type it evaluates to, which is guaranteed to be a <a href="#number">Number</a> in this case.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">char</span>... cs&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c()</div><div class="line">    -&gt; <a class="code" href="group__value.html#gae97c09ebc447382ca7bfbdf64ae8fb00">metal::eval</a>&lt;parse_number&lt;<a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers</a>&lt;cs...&gt;&gt;&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --> <h3>Resolving the Radix</h3>
<p>In its turn <code>parse_number</code> strips the prefix, if any, thus resolving the radix, then forwards the remaining characters to <code>parse_digits</code>, which is in charge of translating the raw characters to the numerical values they represent. The radix and digits are then forwarded to <code>assemble_number</code>, which adds up the individual digits according to the radix.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number {};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;10&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;8&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;x&#39;&gt;, tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;16&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;X&#39;&gt;, tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;16&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;b&#39;&gt;, tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;2&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_number&lt;metal::<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">list</a>&lt;metal::number&lt;&#39;0&#39;&gt;, metal::number&lt;&#39;B&#39;&gt;, tokens...&gt;&gt; {</div><div class="line">    <span class="keyword">using</span> type = assemble_number&lt;metal::number&lt;2&gt;, parse_digits&lt;<a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;tokens...&gt;&gt;&gt;;</div><div class="line">};</div></div><!-- fragment --><p> Notice how we are able to use template pattern matching and partial template specializations to extract all relevant information from the tokens.</p>
<h3>Parsing Digits</h3>
<p>Before translating characters to their corresponding numerical values, we need to get rid of all digit separators that may be in the way. To do that we'll use <code><a class="el" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove</a></code>, which takes a <a href="#list">List</a> <code>l</code> and a <a href="#value">Value</a> <code>val</code> and returns another <a href="#list">List</a> that contains every element in <code>l</code> and in the same order, except for those that are the same as <code>val</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> tokens = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '\'', '7', '\'', '1'&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove</a>&lt;tokens, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;'\''&gt;</a>&gt;, <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a>);</div></div><!-- fragment --><p> The remaining characters can then be individually parsed with the help of <code><a class="el" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform</a></code>, which takes a <a href="#lambda">Lambda</a> <code>lbd</code> and a <a href="#list">List</a> <code>l</code> and returns another <a href="#list">List</a> that contains the <a class="el" href="index.html#value">Values</a> produced by the invocation of <code>lbd</code> for each element in <code>l</code>. </p><pre class="fragment">[lbd(l[0]), lbd(l[1]), ..., lbd(l[n-2]), lbd(l[n-1])]
</pre><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> token&gt;</div><div class="line"><span class="keyword">using</span> parse_digit = <a class="code" href="group__map.html#gafc5fed42b370d7d6a87f342a0c7a7311">metal::at_key</a>&lt;</div><div class="line">    <a class="code" href="group__map.html#ga3638b99b7517ef8f7536d1190bb57d51">metal::map</a>&lt;</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'0'&gt;</a>, metal::number&lt;0&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'1'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;1&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'2'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;2&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'3'&gt;</a>, metal::number&lt;3&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'4'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;4&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'5'&gt;</a>, metal::number&lt;5&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'6'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;6&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'7'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;7&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'8'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;8&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'9'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;9&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'a'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;10&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'b'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;11&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'c'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;12&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'d'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;13&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'e'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;14&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'f'&gt;</a>, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;15&gt;</a>&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'A'&gt;</a>, metal::number&lt;10&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'B'&gt;</a>, metal::number&lt;11&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'C'&gt;</a>, metal::number&lt;12&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'D'&gt;</a>, metal::number&lt;13&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'E'&gt;</a>, metal::number&lt;14&gt;&gt;,</div><div class="line">        <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair&lt;metal::number&lt;'F'&gt;</a>, metal::number&lt;15&gt;&gt;</div><div class="line">    &gt;,</div><div class="line">    token</div><div class="line">&gt;;</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform</a>&lt;<a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;parse_digit&gt;</a>, <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;'3', '7', '1'&gt;</a>&gt;, <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a>);</div></div><!-- fragment --><p> Notice how characters are translated to their actual numerical representation.</p>
<p>Thus we have</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tokens&gt;</div><div class="line"><span class="keyword">using</span> parse_digits = <a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;parse_digit&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#ga843fc599bf7492f8bd91b5c93f0f5cb3">metal::remove&lt;tokens, metal::number&lt;'\''&gt;</a>&gt;</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Assembling Numbers</h3>
<p>We now turn to <code>assemble_number</code>. It takes a <a href="#list">List</a> of digits and adds them up according to the radix, in other words </p><pre class="fragment">D0*radix^(n-1) + D1*radix^(n-2) + ... + D{n-2}*radix + D{n-1}
</pre><p>which can also be written recursively </p><pre class="fragment">((...((0*radix + D0)*radix + D1)*...)*radix + D{n-2})*radix + D{n-1}
</pre><p>This is the equivalent of <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">left folding</a> a <a href="#list">List</a>, or, in Metal parlance, <code><a class="el" href="group__list.html#ga7ec65fe0246335a5e1c549af98c5d7c3">metal::accumulate</a></code>, after its run-time counterpart in the standard library.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> radix = metal::number&lt;10&gt;;</div><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> x, <span class="keyword">typename</span> y&gt;</div><div class="line"><span class="keyword">using</span> expr = <a class="code" href="group__number.html#ga7b0c4a9e92c03313a87716d6a839c5f6">metal::add&lt;metal::mul&lt;radix, x&gt;</a>, y&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;expr&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__list.html#ga7ec65fe0246335a5e1c549af98c5d7c3">metal::accumulate</a>&lt;lbd, metal::number&lt;0&gt;, digits&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;371&gt;</a>);</div></div><!-- fragment --><p> Here we introduced a new <a href="#expression">Expression</a> <code>expr</code> from which we created a <a href="#lambda">Lambda</a>, but we could also have chosen to use <em>bind expressions</em> instead.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> radix = metal::number&lt;10&gt;;</div><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers&lt;3, 7, 1&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;metal::add&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind&lt;metal::lambda&lt;metal::mul&gt;</a>, <a class="code" href="group__lambda.html#ga028cc0f27debcdd281430676951f61bf">metal::always&lt;radix&gt;</a>, <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__list.html#ga7ec65fe0246335a5e1c549af98c5d7c3">metal::accumulate</a>&lt;lbd, metal::number&lt;0&gt;, digits&gt;, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;371&gt;</a>);</div></div><!-- fragment --> <div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"> Tip</span></div><div class="panel-body"> If <em>bind expressions</em> look scary to you, don't panic, we will exercise <a href="#expression">Expression</a> composition in our <a href="#church_booleans">next example</a>. Here it suffices to keep in mind that <em>bind expressions</em> return anonymous <a href="#lambda">Lambdas</a>, just like <a href="http://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a> returns anonymous functions, and that <code><a class="el" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a></code> and <code><a class="el" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a></code> are the equivalents of <a href="http://en.cppreference.com/w/cpp/utility/functional/placeholders"><code>std::placeholders</code></a>. </div></div><p>Finally</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> radix, <span class="keyword">typename</span> digits&gt;</div><div class="line"><span class="keyword">using</span> assemble_number = <a class="code" href="group__list.html#ga7ec65fe0246335a5e1c549af98c5d7c3">metal::accumulate</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">        metal::lambda&lt;metal::add&gt;,</div><div class="line">        metal::bind&lt;metal::lambda&lt;metal::mul&gt;, metal::always&lt;radix&gt;, metal::_1&gt;,</div><div class="line">        metal::_2</div><div class="line">    &gt;,</div><div class="line">    metal::number&lt;0&gt;,</div><div class="line">    digits</div><div class="line">&gt;;</div></div><!-- fragment --> <h3>Fun With <code>operator ""_c</code></h3>
<div class="fragment"><div class="line">IS_SAME(decltype(01234567_c), <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;342391&gt;</a>); <span class="comment">//octal</span></div><div class="line">IS_SAME(decltype(123456789_c), <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;123456789&gt;</a>); <span class="comment">//decimal</span></div><div class="line">IS_SAME(decltype(0xABCDEF_c), <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;11259375&gt;</a>); <span class="comment">//hexadecimal</span></div></div><!-- fragment --><p> It also works for very long binary literals.</p>
<div class="fragment"><div class="line">IS_SAME(</div><div class="line">    decltype(0b111101101011011101011010101100101011110001000111000111000111000_c),</div><div class="line">    <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;8888888888888888888&gt;</a></div><div class="line">);</div></div><!-- fragment --><p> And ignores digit separators too.</p>
<div class="fragment"><div class="line">IS_SAME(decltype(1<span class="charliteral">&#39;2&#39;</span>3<span class="charliteral">&#39;4&#39;</span>5<span class="charliteral">&#39;6&#39;</span>7<span class="charliteral">&#39;8&#39;</span>9_c), <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;123456789&gt;</a>);</div></div><!-- fragment --> <h2><a class="anchor" id="church_booleans"></a>
Church Booleans </h2>
<hr/>
<p><a href="http://en.wikipedia.org/wiki/Church_encoding#Church_Booleans">Church Booleans</a> refer to a mathematical framework used to express logical operation in the context of <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda notation</a>, where they have an important theoretical significance. Of less practical importance in C++, even in the context of template metaprogramming, they will nevertheless help us acquaint with <em>bind expressions</em> in this toy example.</p>
<p>The boolean constants <code>true_</code> and <code>false_</code> are, by definition, <a class="el" href="index.html#lambda">Lambdas</a> that return respectively the first and second argument with which they are <a class="el" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">invoked</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a> = <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a> = <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a>;</div></div><!-- fragment --><p> Now, using the fact that booleans are themselves <a class="el" href="index.html#lambda">Lambdas</a>, it's not too hard to realize that invoking a boolean with arguments <code>&lt;false_, true&gt;</code> always yields its negation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> b&gt;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga3131b106df71656a0f4b06c9fd182b75">not_</a> = <a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;b, false_, true_&gt;</a>;</div><div class="line"></div><div class="line">IS_SAME(not_&lt;true_&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(not_&lt;false_&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div></div><!-- fragment --><p> However, to enable higher-order composition we really need <code>not_</code> to be a <a class="el" href="index.html#lambda">Lambda </a>, not an <a class="el" href="index.html#expression">Expression </a>. Granted one could easily define former in terms of the latter as <code><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a>&lt;not_&gt;</code>, but that would defeat the whole purpose of this exercise, the idea is to use <em>bind expressions</em> directly.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga3131b106df71656a0f4b06c9fd182b75">not_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;metal::invoke&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga028cc0f27debcdd281430676951f61bf">metal::always&lt;false_&gt;</a>, <a class="code" href="group__lambda.html#ga028cc0f27debcdd281430676951f61bf">metal::always&lt;true_&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;not_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;not_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div></div><!-- fragment --><p> Admittedly a little more verbose, but that saves us from introducing a new named alias template.</p>
<p>Using a similar technique, we can also define operators <code>and_</code> and <code>or_</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// x y x y x</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga73d6aa92adfac6cfacb2e935f5b37fb9">and_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a>, metal::_1</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;and_, true_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;and_, true_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;and_, false_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;and_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// x y x x y</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__number.html#ga1411f87040458a68c28936123887ac09">or_</a> = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, metal::_2</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;or_, true_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;or_, true_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;or_, false_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;or_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><p> This exercise might me mind-boggling at first, but you'll get used to it soon enough.</p>
<p>Without further ado we present the logical operator <code>xor</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// x y x (not y) y</span></div><div class="line"><span class="keyword">using</span> xor_ = <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind</a>&lt;</div><div class="line">    metal::lambda&lt;metal::invoke&gt;,</div><div class="line">    <a class="code" href="group__lambda.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#gadc53fa4741d4ac0f180c937b42534049">metal::bind&lt;not_, metal::_2&gt;</a>, metal::_2</div><div class="line">&gt;;</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;xor_, true_, true_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;xor_, true_, false_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;xor_, false_, true_&gt;</a>, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;xor_, false_, false_&gt;</a>, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">false_</a>);</div></div><!-- fragment --><p> Notice how we <em>bind</em> <code>not_</code>, which is only possible due to the fact it is a <a class="el" href="index.html#lambda">Lambda </a>.</p>
<h2><a class="anchor" id="automatic_test_cases_generation"></a>
Automatic Test Cases Generation </h2>
<hr/>
<p>Suppose you have a component you want to test, say an algorithm on sequences. Because it's a generic algorithm, it's able to work with any kind of containers and, as such, is specialized for different categories of iterators so that it always delivers optimal performance. Moreover, to provide exception safety guarantees without compromising on execution time or memory consumption, it must also specialize on <code>noexcept</code> properties of the elements, particularly of their move constructors. Finally, it's conceivable that such a generic algorithm could also take advantage of other properties, such as whether elements can be ordered or not.</p>
<p>As such a complex implementation, it ought to be thoroughly tested for all relevant combinations of iterator categories and interesting properties implemented by the contained elements. Furthermore, it's crucial that all corner cases are covered, such as empty sequences to name the most obvious, so, before we even start to get fancy with our test cases, we already have three dimensions that vary independently, namely</p>
<ol type="1">
<li>Iterator category;</li>
<li>Element properties;</li>
<li>Size of the sequence.</li>
</ol>
<p>How can we possibly implement this testing suite?</p>
<p>First of all, it's a good idea to subdivide each <em>test case</em> into three steps: the set-up phase constructs the particular sequence to be tested, the execution phase runs our algorithm and the tear-down phase releases the resources. This way we can leverage on <a href="http://en.cppreference.com/w/cpp/language/raii">RAII</a> and reduce the boilerplate to a minimum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Type, <span class="keyword">typename</span> Size&gt;</div><div class="line"><span class="keyword">struct </span>test_case {</div><div class="line">    <a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke&lt;Container, Type, std::allocator&lt;Type&gt;</a>&gt; sequence;</div><div class="line"></div><div class="line">    test_case() : sequence(Size{}) { <span class="comment">/* set-up */</span> }</div><div class="line">    ~test_case() { <span class="comment">/* tear-down */</span> }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> operator ()() { <span class="comment">/* algorithm(this-&gt;sequence) */</span> }</div><div class="line">};</div></div><!-- fragment --><p> That's a good start, but in order to run all test cases we still have to manually instantiate each and every combination of iterator categories, element type and sequence size. That is, if we want to test for <code>M</code> different categories of iterators, <code>N</code> sets of interesting properties that could be provided by elements and <code>O</code> different sizes of containers, we end up with <code>M*N*O</code> distinct instantiations to maintain! That's too troublesome and prone to error, there ought to be a way to generate all test cases automatically.</p>
<p>Fortunately Metal can do just that for us. With the help of <code><a class="el" href="group__list.html#ga911c8d82275a42ef12a161e9dc54ac54">metal::cartesian</a></code>, we can generate every test case automatically, which we can then run by instantiating a single driver class. It's actually very simple.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Cases&gt;</div><div class="line"><span class="keyword">struct </span>test_cases : Cases... {</div><div class="line">    <span class="keywordtype">void</span> operator()() {</div><div class="line">        <span class="comment">// call operator () on every base class</span></div><div class="line">        void(std::initializer_list&lt;int&gt;{(<span class="keyword">static_cast&lt;</span>Cases*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<span class="keyword">operator</span>()(), 0)...});</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Containers, <span class="keyword">typename</span> Types, <span class="keyword">typename</span> Sizes&gt;</div><div class="line"><span class="keyword">auto</span> generate_test_cases()</div><div class="line">    -&gt; <a class="code" href="group__lambda.html#ga104b294f047004a8d790863d4292116d">metal::apply</a>&lt;</div><div class="line">        <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;test_cases&gt;</a>,</div><div class="line">        <a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform</a>&lt;</div><div class="line">            <a class="code" href="group__lambda.html#gadfe33a637ed67318cebb9f1cf3a630b3">metal::partial&lt;metal::lambda&lt;metal::apply&gt;</a>, <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;test_case&gt;</a>&gt;,</div><div class="line">            <a class="code" href="group__list.html#ga911c8d82275a42ef12a161e9dc54ac54">metal::cartesian&lt;Containers, Types, Sizes&gt;</a></div><div class="line">        &gt;</div><div class="line">    &gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">using</span> containers = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;std::forward_list&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;std::list&gt;</a>,</div><div class="line">    <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;std::vector&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> types = <a class="code" href="group__list.html#gaf9f79a6875bebc18e071641747908e07">metal::list</a>&lt;A, <span class="comment">/* ..., */</span> Z&gt;;</div><div class="line"><span class="keyword">using</span> sizes = <a class="code" href="group__number.html#gaa21f095617c7a254cf4e95c9a5377fa9">metal::numbers</a>&lt;0, <span class="comment">/* ..., */</span> MAX_SIZE&gt;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> test() {</div><div class="line">    <span class="keyword">auto</span> cases = generate_test_cases&lt;containers, types, sizes&gt;(); <span class="comment">// generate all test cases</span></div><div class="line">    cases(); <span class="comment">// run</span></div><div class="line">}</div></div><!-- fragment --><p> And that was it.</p>
<p>To verify that we are in fact generating all possible combinations of test cases under the hood, let's inspect the return type of <code>generate_test_cases</code></p>
<div class="fragment"><div class="line">IS_SAME(</div><div class="line">    decltype(generate_test_cases&lt;containers, types, sizes&gt;()),</div><div class="line">    test_cases&lt;</div><div class="line">        test_case&lt;metal::lambda&lt;std::forward_list&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::forward_list&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::forward_list&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::forward_list&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;,</div><div class="line"></div><div class="line">        test_case&lt;metal::lambda&lt;std::list&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::list&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::list&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::list&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;,</div><div class="line"></div><div class="line">        test_case&lt;metal::lambda&lt;std::vector&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::vector&gt;, A, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::vector&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MIN_SIZE&gt;</a>&gt;,</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        test_case&lt;metal::lambda&lt;std::vector&gt;, Z, <a class="code" href="group__number.html#gac411a92d2f7b7b88a16c8050151bce1b">metal::number&lt;MAX_SIZE&gt;</a>&gt;</div><div class="line">    &gt;</div><div class="line">);</div></div><!-- fragment --> <h2><a class="anchor" id="SFINAE"></a>
A Word on SFINAE-Friendliness </h2>
<hr/>
<p>An <a href="#expression">Expression</a> is said to be SFINAE-friendly when it is carefully designed so as never to prevent the <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> rule to be triggered. In general, such <a href="#expression">Expressions</a> may only trigger template substitution errors at the point of declaration of a type, which includes the instantiation of <a href="http://en.cppreference.com/w/cpp/language/type_alias">alias templates</a>, default template arguments and the <em>signature</em> of function templates. SFINAE-friendly <a href="#expression">Expressions</a> are exceedingly powerful, because they may be used to drive overload resolution, think <a href="http://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> on steroids. For this reason, <b>all <a href="#expression">Expressions</a> in Metal are guaranteed to be strictly SFINAE-friendly</b>.</p>
<p>Conversely, a SFINAE-unfriendly <a href="#expression">Expression</a> produces so called <em>hard errors</em>, which require the compilation to halt immediately. Examples of <em>hard errors</em> are failed <code>static_assert</code>'ions or template substitution errors at the point of definition of a class or function template. SFINAE-unfriendly <a href="#expression">Expressions</a> are very inconvenient, because they force compilation to halt when they are not selected by overload resolution, thereby hindering the usage of the entire overloaded set.</p>
<h3>make_array</h3>
<p>To illustrate how useful SFINAE-friendliness can be, suppose we need a factory function <code>make_array</code> that takes an arbitrary number of arguments and returns a <code>std::array</code>. Because arrays are homogeneous collections, we need the <em>common type</em> of all its arguments, that is, the type to which every argument can be converted to.</p>
<p>The base case is straightforward.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;std::common_type_t&lt;Xs...&gt;, <span class="keyword">sizeof</span>...(Xs)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Xs&amp;&amp;... xs) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Xs&gt;(xs)...}};</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line">IS_SAME(decltype(make_array(42, 42L, 42LL)), std::array&lt;long long, 3&gt;);</div></div><!-- fragment --><p> Now suppose we need an array of tuples</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono;</div><div class="line"><span class="keyword">using namespace </span>std::literals::chrono_literals;</div><div class="line"><span class="keyword">using namespace </span>std::literals::complex_literals;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tup1 = std::make_tuple(42ns, 0x42, 42.f);</div><div class="line"><span class="keyword">auto</span> tup2 = std::make_tuple(42us, 042L, 42.L);</div><div class="line"><span class="keyword">auto</span> tup3 = std::make_tuple(42ms, 42LL, 42.i);</div></div><!-- fragment --> <div class="strike"> <div class="fragment"><div class="line"><span class="keyword">auto</span> array_of_tuples =  make_array(tup1, tup2, tup3);</div></div><!-- fragment --></div><blockquote class="doxtable">
<p>error: no matching function for call to 'make_array' </p>
</blockquote>
<p>Even though the <em>common tuple</em> is really just a <em>tuple</em> of <em>common types</em>, <code>std::common_type_t</code> is unable to find it in general. That means we need to overload <code>make_array</code> and handle the <em>array of tuples</em> case.</p>
<h3>make_array of tuples</h3>
<p>The idea is to define a metafunction that computes the <em>common tuple</em> from a set of <em>tuples</em> and then use it to overload our factory function.</p>
<p>This sounds like a use-case for Boost.Hana, let's try it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... xs&gt;</div><div class="line"><span class="keyword">using</span> hana_common_tuple_t = <span class="keyword">typename</span> decltype(</div><div class="line">    boost::hana::unpack(</div><div class="line">        boost::hana::zip_with(</div><div class="line">            boost::hana::template_&lt;std::common_type_t&gt;,</div><div class="line">            boost::hana::zip_with(boost::hana::decltype_, std::declval&lt;xs&gt;())...</div><div class="line">        ),</div><div class="line">        boost::hana::template_&lt;std::tuple&gt;</div><div class="line">    )</div><div class="line">)::type;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;std::common_type_t&lt;Xs...&gt;, <span class="keyword">sizeof</span>...(Xs)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R hana_make_array(Xs&amp;&amp;... xs) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Xs&gt;(xs)...}};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;hana_common_tuple_t&lt;std::decay_t&lt;Head&gt;, std::decay_t&lt;Tail&gt;...&gt;, 1 + <span class="keyword">sizeof</span>...(Tail)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R hana_make_array(Head&amp;&amp; head, Tail&amp;&amp;... tail) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Head&gt;(head), std::forward&lt;Tail&gt;(tail)...}};</div><div class="line">}</div></div><!-- fragment --><p> It works as expected for <code>std::tuples</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> array_of_tuples = hana_make_array(tup1, tup2, tup3);</div><div class="line"></div><div class="line">IS_SAME(decltype(array_of_tuples), std::array&lt;std::tuple&lt;nanoseconds, <span class="keywordtype">long</span> <span class="keywordtype">long</span>, std::complex&lt;double&gt;&gt;, 3&gt;);</div></div><!-- fragment --><p> but we get a compilation error as soon as we try to make an array of anything that is not a Boost.Hana <em>Sequence</em>, even though the first overload remains available and would be a perfect match otherwise.</p>
<div class="strike"> <div class="fragment"><div class="line">IS_SAME(decltype(hana_make_array(42, 42L, 42LL)), std::array&lt;long long, 3&gt;);</div></div><!-- fragment --></div><blockquote class="doxtable">
<p>error: static_assert failed "hana::zip_with(f, xs, ys...)
requires 'xs' and 'ys...' to be Sequences" </p>
</blockquote>
<h3>make_array of tuples <em>done right</em></h3>
<p>The reason why Boost.Hana can't help us overload <code>make_array</code> is the fact that it doesn't provide any SFINAE-friendliness guarantees, which essentially means that it cannot be used effectively to control overload resolution. Metal, on the other hand, was carefully designed to never trigger hard errors but rather <em>substitution failures</em>, which makes it able to select candidates from an overloaded set by means of the <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> rule.</p>
<p>Let's try the same approach using Metal.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... xs&gt;</div><div class="line"><span class="keyword">using</span> common_tuple_t = <a class="code" href="group__lambda.html#ga104b294f047004a8d790863d4292116d">metal::apply</a>&lt;</div><div class="line">    std::common_type_t&lt;metal::lambda&lt;std::tuple&gt;, <a class="code" href="group__lambda.html#ga5cd9df7f92f4e646724ee8bbcea685c7">metal::as_lambda&lt;xs&gt;</a>...&gt;,</div><div class="line">    <a class="code" href="group__list.html#ga3ff690c103354f4efc985449a6c57eed">metal::transform&lt;metal::lambda&lt;std::common_type_t&gt;</a>, <a class="code" href="group__list.html#ga0254a66706fd0e05a31f9c0c4029775c">metal::as_list&lt;xs&gt;</a>...&gt;</div><div class="line">&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;std::common_type_t&lt;Xs...&gt;, <span class="keyword">sizeof</span>...(Xs)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Xs&amp;&amp;... xs) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Xs&gt;(xs)...}};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail,</div><div class="line">    <span class="keyword">typename</span> R = std::array&lt;common_tuple_t&lt;std::decay_t&lt;Head&gt;, std::decay_t&lt;Tail&gt;...&gt;, 1 + <span class="keyword">sizeof</span>...(Tail)&gt;</div><div class="line">&gt;</div><div class="line">constexpr R make_array(Head&amp;&amp; head, Tail&amp;&amp;... tail) {</div><div class="line">    <span class="keywordflow">return</span> R{{std::forward&lt;Head&gt;(head), std::forward&lt;Tail&gt;(tail)...}};</div><div class="line">}</div></div><!-- fragment --><p> This time it works not only for <code>std::tuple</code>'s</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> array_of_tuples = make_array(tup1, tup2, tup3);</div><div class="line"></div><div class="line">IS_SAME(decltype(array_of_tuples), std::array&lt;std::tuple&lt;nanoseconds, <span class="keywordtype">long</span> <span class="keywordtype">long</span>, std::complex&lt;double&gt;&gt;, 3&gt;);</div></div><!-- fragment --><p> but also for numerical values</p>
<div class="fragment"><div class="line">IS_SAME(decltype(make_array(42, 42L, 42LL)), std::array&lt;long long, 3&gt;);</div></div><!-- fragment --><p> Again, this only works as expected because of the strict SFINAE-friendliness guarantees provided by Metal.</p>
<h1><a class="anchor" id="quick_start"></a>
Quick Start </h1>
<ol type="1">
<li>Download <a href="http://github.com/brunocodutra/metal/releases">metal.hpp</a></li>
<li><code># include &lt;/path/to/metal.hpp&gt;</code></li>
<li>Love template metaprogramming</li>
</ol>
<h1><a class="anchor" id="MPL"></a>
Migrating from Boost.MPL </h1>
<p>A quick glance Metal and Boost.MPL might look very similar, but because Metal leverages modern language features that were not available at the time Boost.MPL was developed, they are in fact fundamentally distinct.</p>
<h3>Metafunctions</h3>
<p>The representation of <em>metafunctions</em> has been completely redesigned in Metal. Instead of expressing them as class templates that define a nested typename <code>type</code>, Metal assumes <em>metafunctions</em> to be templates, usually but not necessarily alias, that evaluate directly to the result type.</p>
<p>That is, instead of something like this</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>na {};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_1 = na, <span class="keyword">typename</span> arg_2 = na, <span class="comment">/*...*/</span> <span class="keyword">typename</span> arg_n = na&gt;</div><div class="line"><span class="keyword">struct </span>metafunction</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <span class="comment">/*...*/</span> type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_1, <span class="keyword">typename</span> arg_2, <span class="comment">/*...*/</span> <span class="keyword">typename</span> arg_n&gt;</div><div class="line"><span class="keyword">struct </span>compound_metafunction</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> metafunction&lt;</div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_1&gt;::type,</div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_2&gt;::type,</div><div class="line">        <span class="comment">/*...*/</span></div><div class="line">        <span class="keyword">typename</span> metafunction&lt;arg_n&gt;::type</div><div class="line">    &gt;::type type;</div><div class="line">};</div></div><!-- fragment --><p> you should simply write this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... args&gt;</div><div class="line"><span class="keyword">using</span> metafunction = <span class="comment">/*...*/</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... args&gt;</div><div class="line"><span class="keyword">using</span> compound_metafunction = metafunction&lt;metafunction&lt;args&gt;...&gt;;</div></div><!-- fragment --><p> Notice that traditional <em>lazy metafunctions</em> are still valid <a href="#expression">Expressions</a> in Metal, but keep in mind that their nested typename <code>type</code> is never implicitly evaluated.</p>
<div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;std::add_pointer&gt;</a>, <span class="keywordtype">void</span>&gt;, std::add_pointer&lt;void&gt;);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;std::common_type&gt;</a>, <span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;, std::common_type&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;);</div></div><!-- fragment --><p> Don't worry, you can still use <em>lazy metafunctions</em> with Metal just fine, you just need to use the adaptor <code><a class="el" href="group__lambda.html#ga00420618cd4689ece80838e596897d36">metal::lazy</a></code> instead of <code><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a></code>.</p>
<div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#ga00420618cd4689ece80838e596897d36">metal::lazy&lt;std::add_pointer&gt;</a>, <span class="keywordtype">void</span>&gt;, <span class="keywordtype">void</span>*);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#ga00420618cd4689ece80838e596897d36">metal::lazy&lt;std::common_type&gt;</a>, <span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;, <span class="keywordtype">void</span>*);</div></div><!-- fragment --><p> Additionally, you can also explicitly evaluate <em>lazy values</em> using <code><a class="el" href="group__value.html#gae97c09ebc447382ca7bfbdf64ae8fb00">metal::eval</a></code>.</p>
<div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__value.html#gae97c09ebc447382ca7bfbdf64ae8fb00">metal::eval</a>&lt;std::add_pointer&lt;void&gt;&gt;, <span class="keywordtype">void</span>*);</div><div class="line">IS_SAME(<a class="code" href="group__value.html#gae97c09ebc447382ca7bfbdf64ae8fb00">metal::eval</a>&lt;std::common_type&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;&gt;, <span class="keywordtype">void</span>*);</div></div><!-- fragment --> <h3>Type Traits</h3>
<p>Traditionally, <em>type traits</em> are represented as class templates that define a nested integral constant <code>value</code>. Metal on the other hand defines a <em>type trait</em> as any <a href="#expression">Expression</a> that returns a <a href="#number">Number</a>, but that's not to say you can't use good old <em>type traits</em> with Metal just fine, on the contrary, in a similar fashion to <em>lazy metafunctions</em>, all you have to do is use the trait adaptor <code><a class="el" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait</a></code> instead of <code><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a></code>.</p>
<div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_pointer&gt;</a>, <span class="keywordtype">void</span>*&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_pointer&gt;</a>, <span class="keywordtype">void</span>()&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>);</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_convertible&gt;</a>, <span class="keywordtype">char</span>[], <span class="keywordtype">void</span>*&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__lambda.html#gab55bec3884b050822e67739389d9f7a4">metal::invoke</a>&lt;<a class="code" href="group__lambda.html#gaa1d838da057cf0ff4c26bb2e66283fea">metal::trait&lt;std::is_convertible&gt;</a>, <span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>);</div></div><!-- fragment --><p> Alternatively, you can also explicitly convert <em>traits</em> to <a href="#number">Numbers</a> using <code><a class="el" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a></code>.</p>
<div class="fragment"><div class="line">IS_SAME(<a class="code" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a>&lt;std::is_pointer&lt;void*&gt;&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a>&lt;std::is_pointer&lt;<span class="keywordtype">void</span>()&gt;&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>);</div><div class="line"></div><div class="line">IS_SAME(<a class="code" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a>&lt;std::is_convertible&lt;<span class="keywordtype">char</span>[], <span class="keywordtype">void</span>*&gt;&gt;, <a class="code" href="group__number.html#gadff72c366480cfd6569d65e0e70a2a27">metal::true_</a>);</div><div class="line">IS_SAME(<a class="code" href="group__number.html#ga4b9051aa8c4842c4e7d06c1608af6dfc">metal::as_number</a>&lt;std::is_convertible&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">char</span>[]&gt;&gt;, <a class="code" href="group__number.html#ga2b8268fd8b95748afa8db51554554ba7">metal::false_</a>);</div></div><!-- fragment --> <h3>Metafunction Classes</h3>
<p>The concept of <em>Metafunction Class</em> became obsolete with Metal. Instead of defining <a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class</a> metafunctions like you would with Boost.MPL</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>first_class_metafunction</div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_1, <span class="keyword">typename</span> arg_2, <span class="comment">/*...*/</span> <span class="keyword">typename</span> arg_n&gt;</div><div class="line">    <span class="keyword">struct </span><a class="code" href="group__lambda.html#ga104b294f047004a8d790863d4292116d">apply</a> {</div><div class="line">        <span class="keyword">typedef</span> <span class="comment">/*...*/</span> type;</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p> you just have to wrap regular metafunctions using <code><a class="el" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda</a></code> instead</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... args&gt;</div><div class="line"><span class="keyword">using</span> metafunction = <span class="comment">/*...*/</span>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> first_class_metafunction = <a class="code" href="group__lambda.html#gaeea7c9ee303b80696b07eb8c6c8ee53c">metal::lambda&lt;metafunction&gt;</a>;</div></div><!-- fragment --><p> It's that simple.</p>
<h1><a class="anchor" id="FAQ"></a>
Frequently Asked Questions </h1>
<h2><a class="anchor" id="FAQ_MPL"></a>
What are some advantages of Metal with respect to Boost.MPL? </h2>
<hr/>
<p>The most apparent advantage of Metal with respect to Boost.MPL is the fact Metal <a href="#list">Lists</a> and <a href="#map">Maps</a> can easily exceed the hundreds and even thousands of elements with little impact to the compiler performance, whereas Boost.MPL <em>Sequences</em>, such as <code>mpl::vector</code> and <code>mpl::map</code>, are hard-limited to at most a couple dozen elements and even then at much longer compilation times and higher memory consumption than Metal. Another obvious improvement in Metal is the much terser syntax made possible by alias templates, which were not available at the time Boost.MPL was developed.</p>
<p>Visit <a href="http://metaben.ch/">metaben.ch</a> for up to date benchmarks that compare Metal against Boost.MPL and other notable metaprogramming libraries. For a brief discussion about fundamental design differences between Boost.MPL and Metal, refer to <a class="el" href="index.html#MPL">Migrating from Boost.MPL </a>.</p>
<h2><a class="anchor" id="FAQ_Hana"></a>
What are some advantages of Metal with respect to Boost.Hana? </h2>
<hr/>
<p>As a tool specifically designed for type level programming, Metal is able to provide stronger guarantees and much faster compilation times than Boost.Hana when used for similar purposes. In fact, Metal guarantees SFINAE-friendliness, whereas Boost.Hana does not. Check out <a class="el" href="index.html#SFINAE">A Word on SFINAE-Friendliness </a> for a real world example of the limitations of Boost.Hana with this respect.</p>
<p>Moreover, since Metal <a href="#definitions">concepts</a> are defined by their type signatures, it is always safe to use template pattern matching on them to partially specialize class templates or overload function templates. In contrast, the types of most Boost.Hana objects are left unspecified.</p>
<h2><a class="anchor" id="FAQ_numbers"></a>
Why isn't std::integral_constant a Number in general? </h2>
<hr/>
<p><a href="#number">Numbers</a> are defined as a specific specialization of <code>std::integral_constant</code>s, whose binary representation is fixed to <code><a class="el" href="group__number.html#ga4e051f5efd9de86772e0622414cee2df">metal::int_</a></code>, an implementation-defined integral type. This design choice stems from the fact two <a href="#value">Values</a> compare equal if and only if they have the same type signature. As <a href="#value">Values</a> themselves, <a href="#number">Numbers</a> are also subject to this requirement, thus had <a href="#number">Numbers</a> been defined as a numerical value <em>plus</em> its binary representation, would two <a href="#number">Numbers</a> only compare equal if they had both the same numerical value <em>and</em> the same binary representation. This is unreasonable in the context of metaprogramming, where the binary representation of numerical values is entirely irrelevant. </p>
</div></div><!-- contents -->
        </div>
      </div>
    </div>
    <div id="footer">
      <div class="container">
        <div class="row text-muted">
          <div class="col-md-12">
            <ul class="list-inline">
              <li><iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=watch&amp;count=true" title="Star on GitHub"></iframe></li>
              <li><iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=fork&amp;count=true" title="Fork on GitHub"></iframe></li>
            </ul>
            &copy; Copyright 2015-2017
            <a href="https://github.com/brunocodutra">Bruno Dutra</a>,
            <span class="hidden-xs">Distributed under the</span>
            <a href="http://www.boost.org/LICENSE_1_0.txt">
              Boost Software License, Version 1.0
            </a>
          </div>
        </div>
      </div>
    </div>
    <script>
      /*!
       * IE10 viewport hack for Surface/desktop Windows 8 bug
       * Copyright 2014-2015 Twitter, Inc.
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
       */
      (function () {
        'use strict';
        if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
          var msViewportStyle = document.createElement('style')
          msViewportStyle.appendChild(
            document.createTextNode(
              '@-ms-viewport{width:auto!important}'
            )
          )
          document.querySelector('head').appendChild(msViewportStyle)
        }
      })();
    </script>
  </body>
</html>
